# **python规范**
## 命名
### G.NAM.01 使用统一的命名风格
1. 只有类需要采用驼峰命名，别的都采用小写字母+下划（lower_with_under）线即可
    - 包（Package）、模块（Module）名使用意义完整的英文描述，采用小写加下划线
    - 类（Class）名使用意义完整的英文描述，采用大写字母开头的单词（CapWords）风格命名。
    - 函数（Function）、方法（Method）使用意义完整的英文描述，采用小写加下划线的风格命名。
    - 类或对象的保护成员一般用单下划线_ 开头，私有成员一般用双下划线__开头
    - 变量（Variable）、类的数据成员（Data Member）、函数的参数(Parameter)采用小写加下划线的风格命名。
    - 特殊情况：常量（Constant）采用大写加下划线

2. 函数下划线
    - 对于不想公开的函数，卡宴采用约定俗成的方式去以_开头来暗示其属于内部使用
    - 双下划线__ 开头的成员会被解释器自动改名，加上类名作为前缀，其作用是防止在类继承场
景中出现名字冲突，并不具有权限控制的作用，外部仍然可以访问。

3. 举例
    - 正例
```python
class MyClass:
    def __init__(self):
        self._member = 1

    def my_method(self):
        # 单下划线开头，暗示此成员仅供类的内部操作使用，外部不应该访问。
        self._member += 1

    # 单下划线开头，暗示此方法仅供类的内部操作使用，外部不应该访问。
    def _my_protected_method(self):
        pass


class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    # 双下划线开头，会被解释器改名为_Mapping__update。外部如果使用修改后的名字仍可访问。
    def __update(self, iterable):
        for item in iterable:
            self.items_list.append(item)


class MappingSubclass(Mapping):
    # 双下划线开头，会被解释器改名为_MappingSubclass__update。不会跟基类成员重名。
    def __update(self, keys, values):
        for item in zip(keys, values):
            self.items_list.append(item)


import enum


class State(enum.Enum):
    # 常量采用大写字母+下划线
    '''The internal state used for parsing the input file.'''
    NORMAL = 0
    IGNORE = 1
```

### G.NAM.02 命名要有明确含义，以提升代码的可读性

- 反例
```python
class Student:
    pass

def example_function():
    i = Student() # 不符合，使用i作为变量名，影响可读性
    o = [l for l in range(1)] # 不符合，字符l和数字1很容易混淆，字符o和数字0容易混淆
```
- 正例

```python
class Student:
    pass

def example_function():
    student_chen = Student() # 符合
    number_list = [i for i in range(10)] # 符合，局部循环变量使用i
```
- 正例
```python
with open(filename, mode='r') as f:
    for i in f.readlines(): # 符合，作用域较小且无二义性
        print(i)
```

### G.NAM.03“self”应是实例方法的第一个参数，“cls”应是类方法的第一个参数

- 就一句话，实例方法的第一个参数是“self”，类方法（被@classmethod装饰的函数）的第一个参数是
“cls”
- 反例
    
```python
class Student:
    def set_information(student, name, age, sex): 
        # 不符合，实例方法中使用student代替self，可读性降低
        print("student information")
    def add_information(rank): # 不符合，该实例方法忘记写self参数
        print(rank)

if __name__ == '__main__':
    monitor = Student()
    monitor.set_information('lucy', 18, 0) # 调用成功
    monitor.add_information(1) # 调用实例方法出错
```
- 正例
```python
class Student:
    def set_information(self, name, age, sex):
        # 符合，实例方法的第一个参数是self
        print("student information")


def add_information(self, rank):
    # 符合，实例方法的第一个参数是self
    print(rank)
```
- 反例
```python
class Student:
    @classmethod
    def total():  # 类方法total缺少cls参数
        print("total count")
```
- 正例
```python
class Student:
    @classmethod
    def total(cls): # 类方法total的第一个位置参数是cls
        print("total count")
```

### G.NAM.04 避免在无关的标识符或无关的概念之间重用名字， 避免因重名而导致的意外赋值和错误引用

- python引用时遵循LEGB顺序（Local-Enclosed-Global-Builtin），从内层一直查找到外层
- 虽然重复的变量在python中并不会引起报错，但是也依旧会引起很多问题，因此不推荐这么做
- 以下场景应当避免：
    - 避免和内置函数、内置类以及Python关键字重复
    - 避免重复定义函数、类，避免导入模块重名，避免相同变量
    
- 反例
```python
def function(para, type): # 参数名遮盖了builtin函数type
    ...
    para_type = type(para) # type被遮盖为函数参数，不是builtin的实现

from os import path

for path in ['file1.py', 'file2.py']: # 循环变量path与导入的对象path重名
    print(path)

def not_redefine_argument(file_name):
    with open('
    file.py') as file_name: # 这里的file_name变量与函数参数名称重名，可能导致潜在的错误
        pass
```
- 正例
```python
from os import path

for file_name in ['file1.py', 'file2.py']:
    print(file_name)


def redefine_argument(file_name):
    with open('file.py') as some_file:
        pass

```

### G.NAM.05 除了需要重写魔法函数、对象之外，不推荐使用双下划线开头且双下划线结尾的标识符来命名一般对象

- python本身自带不少带**双下划线开头双下划线结尾**的函数，这些函数除非要重写，不然不推荐采取这种命名方式

- 反例
```python
class MyClass:
    def __init__(self):
        pass
    def __myfunction__(self, param): 
        # 不符合，这是自定义方法，不应该采用以双下划线开头且双下划线结尾的方式命名
        pass
```
- 正例
```python
class MyClass:
    def __init__(self):
        pass
    def my_function(self, param): # 符合
        pass
    def __my_private_function(self, param): 
        # 符合，仅以双下划线开头的方法，属于对象私有的方法
    pass
```
## 注释

### G.CMT.01 模块文档字符串写在文件的顶部，Shebang和文件编码声明之后，导入(imports) 部分之前的位置，不需要缩进
- 正例
```python
#!/usr/bin/env python
# coding: utf-8
# 版权所有 (c) 华为技术有限公司 2012-2020
"""这是一个模块文档字符串的总体描述。

详细的功能描述建议和上面的总体描述空一行分隔。

可列出该模块导出的类，函数（以及任何其他对象）、异常等信息，并以每个一段的形式摘要描述。
（这些摘要通常比对象的docstring中的摘要行提供的细节少。）

包的docstring（即，包的__init__.py模块的docstring ）也应列出该包导出的模块和子包。
"""

from __future__ import barry_as_FLUFL

__all__ = []

import os
import sys
```
### G.CMT.02 类的文档字符串写在类声明(class ClassName:)所在行的下一行，并向后缩进4个空格

- 【正例】单行文档字符串

```python
class ErrorClass(Exception):
    """Base class for I/O related errors."""
    def __init__(self, *args, **kwargs):
        pass
```
- 【正例】多行文档字符串
```python
class ExampleClass:
    """类文档字符串的摘要行应该放在一行上。

    如果类有公共属性，它们可以在这里用一个``Attributes``部分来文档化，
    并遵循与函数的``Args``部分相同的格式。或者，属性可以与属性的声明
    内联文档化（参见下面的__init__方法）。

    用``@property``装饰器创建的属性应该在属性的getter方法中文档化。

    属性：
        attr1 (str): `attr1`的描述。
        attr2 (:obj:`int`, optional): `attr2`的描述。
    """
def __init__(self, param1, param2, param3):
    """__init__方法的文档字符串示例。

    __init__方法可以在类级别的文档字符串中，或者在__init__方法本身的
    文档字符串中进行文档化。

    两种形式都是可以接受的，但不要混合使用。选择一种约定来文档化
    __init__方法，并保持一致。

    注意：
        不要在``Args``部分中包含`self`参数。
    参数：
        param1 (str): `param1`的描述。
        param2 (:obj:`int`, optional): `param2`的描述。支持多行。
        param3 (:obj:`list` of :obj:`str`): `param3`的描述。
        
    """
    self.attr1 = param1
    self.attr2 = param2
```
### G.CMT.03 公共函数的文档字符串写在函数声明(def function_name(param):)所在行的下一行，并向后缩进4个空格

- 【正例】单行文档字符串

```python
def get_freeze_count(*args, **kwargs): # real signature unknown
    """ Return the number of objects in the permanent generation. """
    pass                
```
- 【正例】多行文档字符串的示例是采用的Google风格，也可以采用Pycharm reStructedText风格，只要项目组内的注释风格保持一致就可以。

```python
def select_function(rlist, wlist, xlist, timeout=None):
    """Wait until one or more file descriptors are ready for some kind of I/O.
    If only one kind of condition is required, pass [] for the other lists.
    A file descriptor is either a socket or file object, or a small integer
    gotten from a fileno() method call on one of those.
    Args:
    rlist: wait until ready for reading
    wlist: wait until ready for writing
    xlist: wait for an ``exceptional condition''
    Return:
    a tuple of three lists corresponding to the first three
    arguments; each contains the subset of the corresponding file
    descriptors
    that are ready.
    Optional parameters:
    specifies a timeout in seconds; it may be
    a floating point number to specify fractions of seconds. If it is
    absent
    or None, the call will never time out.
    Raises:
    IOErrorr: An error...
    """
    pass
```

### P.01 注释跟代码一样重要，应按需注释
- 尽量通过清晰的软件架构、良好的标识符命名来提高代码可读性；在需要的时候，才辅以注释说明。对晦涩难懂的代码、命名，应该考虑重构而不是添加注释。
- 注释应当简洁明了无歧义，尽量避免冗余信息，注释语言应该整个团队保持统一

### G.CMT.04 代码的注释位置和格式应该在项目内保持统一

- 代码注释有两种方式：1. 代码上方加，这种情况要保证缩进一致，2. 行尾添加，这个需要与行尾间隔2个空格
- 要么全程采用方式1要么全程方式2

- 【反例】 注释虽然放在代码段的上方，但没有和被注释代码段保持同样的缩进。
```python
    # Get replicate sub system index and net indicator
repssn_ind = ssn_data[index].repssn_index
repssn_ni = ssn_data[index].ni
```
