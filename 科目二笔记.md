# **python规范**
## 命名
### G.NAM.01 使用统一的命名风格
1. 只有类需要采用驼峰命名，别的都采用小写字母+下划（lower_with_under）线即可
    - 包（Package）、模块（Module）名使用意义完整的英文描述，采用小写加下划线
    - 类（Class）名使用意义完整的英文描述，采用大写字母开头的单词（CapWords）风格命名。
    - 函数（Function）、方法（Method）使用意义完整的英文描述，采用小写加下划线的风格命名。
    - 类或对象的保护成员一般用单下划线_ 开头，私有成员一般用双下划线__开头
    - 变量（Variable）、类的数据成员（Data Member）、函数的参数(Parameter)采用小写加下划线的风格命名。
    - 特殊情况：常量（Constant）采用大写加下划线

2. 函数下划线
    - 对于不想公开的函数，卡宴采用约定俗成的方式去以_开头来暗示其属于内部使用
    - 双下划线__ 开头的成员会被解释器自动改名，加上类名作为前缀，其作用是防止在类继承场
景中出现名字冲突，并不具有权限控制的作用，外部仍然可以访问。

3. 举例
    - 正例
```python
class MyClass:
    def __init__(self):
        self._member = 1

    def my_method(self):
        # 单下划线开头，暗示此成员仅供类的内部操作使用，外部不应该访问。
        self._member += 1

    # 单下划线开头，暗示此方法仅供类的内部操作使用，外部不应该访问。
    def _my_protected_method(self):
        pass


class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    # 双下划线开头，会被解释器改名为_Mapping__update。外部如果使用修改后的名字仍可访问。
    def __update(self, iterable):
        for item in iterable:
            self.items_list.append(item)


class MappingSubclass(Mapping):
    # 双下划线开头，会被解释器改名为_MappingSubclass__update。不会跟基类成员重名。
    def __update(self, keys, values):
        for item in zip(keys, values):
            self.items_list.append(item)


import enum


class State(enum.Enum):
    # 常量采用大写字母+下划线
    '''The internal state used for parsing the input file.'''
    NORMAL = 0
    IGNORE = 1
```

### G.NAM.02 命名要有明确含义，以提升代码的可读性

- 反例
```python
class Student:
    pass

def example_function():
    i = Student() # 不符合，使用i作为变量名，影响可读性
    o = [l for l in range(1)] # 不符合，字符l和数字1很容易混淆，字符o和数字0容易混淆
```
- 正例

```python
class Student:
    pass

def example_function():
    student_chen = Student() # 符合
    number_list = [i for i in range(10)] # 符合，局部循环变量使用i
```
- 正例
```python
with open(filename, mode='r') as f:
    for i in f.readlines(): # 符合，作用域较小且无二义性
        print(i)
```

### G.NAM.03“self”应是实例方法的第一个参数，“cls”应是类方法的第一个参数

- 就一句话，实例方法的第一个参数是“self”，类方法（被@classmethod装饰的函数）的第一个参数是
“cls”
- 反例
    
```python
class Student:
    def set_information(student, name, age, sex): 
        # 不符合，实例方法中使用student代替self，可读性降低
        print("student information")
    def add_information(rank): # 不符合，该实例方法忘记写self参数
        print(rank)

if __name__ == '__main__':
    monitor = Student()
    monitor.set_information('lucy', 18, 0) # 调用成功
    monitor.add_information(1) # 调用实例方法出错
```
- 正例
```python
class Student:
    def set_information(self, name, age, sex):
        # 符合，实例方法的第一个参数是self
        print("student information")


def add_information(self, rank):
    # 符合，实例方法的第一个参数是self
    print(rank)
```
- 反例
```python
class Student:
    @classmethod
    def total():  # 类方法total缺少cls参数
        print("total count")
```
- 正例
```python
class Student:
    @classmethod
    def total(cls): # 类方法total的第一个位置参数是cls
        print("total count")
```

### G.NAM.04 避免在无关的标识符或无关的概念之间重用名字， 避免因重名而导致的意外赋值和错误引用

- python引用时遵循LEGB顺序（Local-Enclosed-Global-Builtin），从内层一直查找到外层
- 虽然重复的变量在python中并不会引起报错，但是也依旧会引起很多问题，因此不推荐这么做
- 以下场景应当避免：
    - 避免和内置函数、内置类以及Python关键字重复
    - 避免重复定义函数、类，避免导入模块重名，避免相同变量
    
- 反例
```python
def function(para, type): # 参数名遮盖了builtin函数type
    ...
    para_type = type(para) # type被遮盖为函数参数，不是builtin的实现

from os import path

for path in ['file1.py', 'file2.py']: # 循环变量path与导入的对象path重名
    print(path)

def not_redefine_argument(file_name):
    with open('
    file.py') as file_name: # 这里的file_name变量与函数参数名称重名，可能导致潜在的错误
        pass
```
- 正例
```python
from os import path

for file_name in ['file1.py', 'file2.py']:
    print(file_name)


def redefine_argument(file_name):
    with open('file.py') as some_file:
        pass

```

### G.NAM.05 除了需要重写魔法函数、对象之外，不推荐使用双下划线开头且双下划线结尾的标识符来命名一般对象

- python本身自带不少带**双下划线开头双下划线结尾**的函数，这些函数除非要重写，不然不推荐采取这种命名方式

- 反例
```python
class MyClass:
    def __init__(self):
        pass
    def __myfunction__(self, param): 
        # 不符合，这是自定义方法，不应该采用以双下划线开头且双下划线结尾的方式命名
        pass
```
- 正例
```python
class MyClass:
    def __init__(self):
        pass
    def my_function(self, param): # 符合
        pass
    def __my_private_function(self, param): 
        # 符合，仅以双下划线开头的方法，属于对象私有的方法
    pass
```
## 注释

### G.CMT.01 模块文档字符串写在文件的顶部，Shebang和文件编码声明之后，导入(imports) 部分之前的位置，不需要缩进
- 正例
```python
#!/usr/bin/env python
# coding: utf-8
# 版权所有 (c) 华为技术有限公司 2012-2020
"""这是一个模块文档字符串的总体描述。

详细的功能描述建议和上面的总体描述空一行分隔。

可列出该模块导出的类，函数（以及任何其他对象）、异常等信息，并以每个一段的形式摘要描述。
（这些摘要通常比对象的docstring中的摘要行提供的细节少。）

包的docstring（即，包的__init__.py模块的docstring ）也应列出该包导出的模块和子包。
"""

from __future__ import barry_as_FLUFL

__all__ = []

import os
import sys
```
### G.CMT.02 类的文档字符串写在类声明(class ClassName:)所在行的下一行，并向后缩进4个空格

- 【正例】单行文档字符串

```python
class ErrorClass(Exception):
    """Base class for I/O related errors."""
    def __init__(self, *args, **kwargs):
        pass
```
- 【正例】多行文档字符串
```python
class ExampleClass:
    """类文档字符串的摘要行应该放在一行上。

    如果类有公共属性，它们可以在这里用一个``Attributes``部分来文档化，
    并遵循与函数的``Args``部分相同的格式。或者，属性可以与属性的声明
    内联文档化（参见下面的__init__方法）。

    用``@property``装饰器创建的属性应该在属性的getter方法中文档化。

    属性：
        attr1 (str): `attr1`的描述。
        attr2 (:obj:`int`, optional): `attr2`的描述。
    """
def __init__(self, param1, param2, param3):
    """__init__方法的文档字符串示例。

    __init__方法可以在类级别的文档字符串中，或者在__init__方法本身的
    文档字符串中进行文档化。

    两种形式都是可以接受的，但不要混合使用。选择一种约定来文档化
    __init__方法，并保持一致。

    注意：
        不要在``Args``部分中包含`self`参数。
    参数：
        param1 (str): `param1`的描述。
        param2 (:obj:`int`, optional): `param2`的描述。支持多行。
        param3 (:obj:`list` of :obj:`str`): `param3`的描述。
        
    """
    self.attr1 = param1
    self.attr2 = param2
```
### G.CMT.03 公共函数的文档字符串写在函数声明(def function_name(param):)所在行的下一行，并向后缩进4个空格

- 【正例】单行文档字符串

```python
def get_freeze_count(*args, **kwargs): # real signature unknown
    """ Return the number of objects in the permanent generation. """
    pass                
```
- 【正例】多行文档字符串的示例是采用的Google风格，也可以采用Pycharm reStructedText风格，只要项目组内的注释风格保持一致就可以。

```python
def select_function(rlist, wlist, xlist, timeout=None):
    """Wait until one or more file descriptors are ready for some kind of I/O.
    If only one kind of condition is required, pass [] for the other lists.
    A file descriptor is either a socket or file object, or a small integer
    gotten from a fileno() method call on one of those.
    Args:
    rlist: wait until ready for reading
    wlist: wait until ready for writing
    xlist: wait for an ``exceptional condition''
    Return:
    a tuple of three lists corresponding to the first three
    arguments; each contains the subset of the corresponding file
    descriptors
    that are ready.
    Optional parameters:
    specifies a timeout in seconds; it may be
    a floating point number to specify fractions of seconds. If it is
    absent
    or None, the call will never time out.
    Raises:
    IOErrorr: An error...
    """
    pass
```

### P.01 注释跟代码一样重要，应按需注释
- 尽量通过清晰的软件架构、良好的标识符命名来提高代码可读性；在需要的时候，才辅以注释说明。对晦涩难懂的代码、命名，应该考虑重构而不是添加注释。
- 注释应当简洁明了无歧义，尽量避免冗余信息，注释语言应该整个团队保持统一

### G.CMT.04 代码的注释位置和格式应该在项目内保持统一

- 代码注释有两种方式：1. 代码上方加，这种情况要保证缩进一致，2. 行尾添加，这个需要与行尾间隔2个空格
- 要么全程采用方式1要么全程方式2

- 【反例】 注释虽然放在代码段的上方，但没有和被注释代码段保持同样的缩进。
```python
    # Get replicate sub system index and net indicator
repssn_ind = ssn_data[index].repssn_index
repssn_ni = ssn_data[index].ni
```
- 【反例】 注释放在了被注释代码段的下方。
```python
epylint_part = [executable, "-c", "from pylint import epylint;epylint.Run()"]
# Create command line to call pylint
```
- 【正例】 注释放在行尾，与代码尾部间隔至少两个空格。
```python
repssn_ind = ssn_data[index].repssn_index # Get replicate sub system index and
net indicator
```
- 【正例】 注释放在语句块上方，并和被注释代码段保持同样的缩进。#后面空一格写注释内容。
```python
# Create command line to call pylint
epylint_part = [executable, "-c", "from pylint import epylint;epylint.Run()"]
```
### G.CMT.05 正式交付给客户的代码不应包含TODO/FIXME注释
- 下列注释交付前必须全部处理
```python
# TODO: 补充XX处理
# FIXME: XX缺陷
```
### G.CMT.06 文件头注释应该包含版权许可信息
- 【正例】(中文版)
```python
#!/usr/bin/python3.7
# -*- coding: utf-8 -*-
# 版权所有 (c) 华为技术有限公司 2012-2020
```
- 【正例】(英文版)
```python
#!/usr/bin/python3.7
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2012-2020. All rights reserved.
```
- 012-2020 根据实际需要可以修改。 2012 是文件首次创建年份，而2020 是最后文件修改年份

## 格式
### G.FMT.01 程序块应该采用4个空格缩进风格编写

- 【反例】
```python
for key, value in x_dict.items():
    if value == 98:
      print(key) # 不符合，该语句缩进太少，只有2个空格
```
- 【正例】
```python
for _, value in x_dict.items():
    if value < 100:
        print('value小于100')
    elif value > 100:
        print('value大于100')
    else:
        print('value等于100')
```
- 【反例】
```python
number = input('Input an integer:')

if number == '0':
    print('输入的0。')
else:
        print('输入的不是0。')  # 不符合，if代码块内的语句是4个空格缩进，该语句是8个空格缩进，缩进量不一致
```
- 【正例】
```python
number = input('Input an integer:')

if number == '0':
    print('输入的0。')
else:
    print('输入的不是0。')  # 符合，相同级别的代码具有相同的缩进量
```
### G.FMT.02 行宽不超过120个字符
- 一行可别写太长了
### G.FMT.03 合理安排空行
- 可参考如下建议
    - 减少不必要空行，仅在有明显逻辑分组的时候使用，最多两个空行
    - 类中的方法定义之间空一行
    - 相对独立的逻辑代码块之间，变量说明之后建议空一行
- 【反例】
```python
def function_name():
...
# 空行
# 空行
# 空行
# 空行
class Example: # 不符合，顶级的函数定义与类定义之间应该空两个空行
    ...
```
- 【正例】
```python
def function_name():
    do_something()
# 空行
# 空行
class Example: # 符合
    ...
```
- 【正例】
```python
class Animal:
    def eat(self):
        print("Can i eat?")
    # 空行
    def sleep(self): # 符合，类中的方法定义之间空一行
        print("i want to sleep.")
```
- 【反例】
```python
if len(device_name) < MAX_NAME_LEN:
    ...
writer = log_writer() # 不符合，相对独立的程序块之间未加空行
```
- 【正例】
```python
if len(device_name) < MAX_NAME_LEN:
    ...
# 空行
writer = log_writer()
```
- 【正例】
```python
if len(device_name) < MAX_NAME_LEN:
    ...
# 空行
writer = log_writer()
```
### G.FMT.04 用空格突出关键字和重要信息
- 建议级别，直接看案例
```python
print(current,data,data_list) # 不符合，逗号后面没有加空格
print(current, data, data_list) # 符合


total=addend + added_data # 不符合，赋值操作符“=”的前后没有加空格
total = addend + added_data # 符合

addend+=2 # 不符合，赋值操作符"+="的前后没有加空格
addend += 2 # 符合

if current_time>=MAX_TIME_VALUE: # 不符合，比较操作符">="的前后没有加空格
    pass
if current_time >= MAX_TIME_VALUE: # 符合
    pass

result. write_log() # 不符合，“.”后面添加了空格
result.write_log() # 符合，“.”后面不加空格

a = ( (b + c) * d - 5) * 6 # 不符合，多重括号间添加了空格
a = ((b + c) * d - 5) * 6 # 符合

def sample(constant : int=1)->str: # 不符合，“:”前添加了空格 ，参数类型定义时赋值操作符“=”的前后没有加空格，“->”前后没有添加空格
    pass
def sample(constant: int = 1) -> str: # 符合
    pass


my_dict [key] = my_list [index] # 不符合，紧贴索引切片或被调用函数名，开始的括号前，添加了空格。
my_dict[key] = my_list[index] # 符合

conn = Telnet.connect (ip_address) # 不符合
conn = Telnet.connect(ip_address) # 符合

# 其他正例
total = multiplier * multiplicand # 符合，操作符"*"、"**"，前后可以加空格
total = radix ** power_nums
total = radix*2 - 1 # 符合，这里的操作符"*"前后不建议加空格
def create(self, name=None): # 符合，参数默认值以及调用函数传递参数时使用的等号，前后不加空格
    self.create(name="mike")
```
### G.FMT.05 导入部分(imports)应该置于模块注释和文档字符串之后，模块全局变量和常量声明之前
- 【正例】
```python
"""This is a module
Functions of this module
"""

# 导入部分位于文档字符串之后，全局变量之前
import os
import sys

sample_global_variable = 0
M_SAMPLE_GLOBAL_CONSTANT = 0
```
- 【正例】有类似于__all__ 、__version__ 这种全局变量的特殊情况
```python
"""This is a module
Functions of this module
"""

from __future__ import print_function

__all__ = ['hello', 'world']
__version__ = 'V1.0'

import os
import sys
from time import sleep
```
### G.FMT.06 每行只能导入一个模块
- 一行只允许导入一个模块，但允许从一个模块导入多个对象
- 【反例】
```python
import os, sys # 不符合，一行导入了两个库
```
- 【正例】
```python
from sys import stdin, stdout
from moviepy.editor import (VideoFileClip, TextClip,
                        CompositeVideoClip, ColorClip) # 如果一行代码太长，可以放到元组中，然后换行
```
### G.FMT.07 导入部分(imports)应该按照标准库、第三方库、应用程序自定义模块的顺序排列导入
- 建议按如下顺序导入
    - 标准库
    - 第三方库
    - 自定义模块
- 【正例】
```python
import os
import sys

from oslo_config import cfg
from oslo_log import log as logging

from cinder import context
from cinder import db
```
- 【正例】__future__ 模块的导入放在最前面
```python
from __future__ import print_function

import os
import sys
from time import sleep
```
- 【例外】针对部分模块不在标准python安装路径下或需要进行导入优先级调整的情况下，被调整模块与
其他模块间的先后顺序可以不满足此条款。
```python
import os
import sys

sys.path.insert('/home/models') # 绝对路径
from models.file import functionA
```
### G.FMT.08 一行只写一条语句
- 【反例】
```python
rect.length = 0; rect.width = 0;
```
### G.FMT.09 合理的运用换行和缩进
- 过长语句可以使用换行符
```python
var_sum = long_var_int_one + long_var_int_two + long_var_int_three + \
          long_var_int_four + long_var_int_five + long_var_int_six

result = function_name(param_name1, param_name2） # 符合

result = function_name(param_name1, param_name2,
                    param_name3, param_name4) # 符合

data = {'key1': 12, # 不符合，'key1'没有和'key2'对齐
       'key2': 23,
}

data = {'key1': 12,
        'key2': 23} # 不符合，右括号没有单独成一行

data = {'hello',
        'world'
        } # 不符合，右括号应该和data对齐

data = {'key1': 12, 'key2': 23} # 符合，左括号和右括号在同一行

data = {
    'key1': 12,
    'key2': 23,
} # 符合，左括号后面换行，右括号和左括号所在行的第一列对齐，且最后一个元素后面保留逗号

foo = [
    'hello', 'world',
] # 符合，左括号后面换行，右括号和左括号所在行的第一列对齐


[x*y for x in range(20)
for y in range(20) if x*y > 200] # 过长表达式建议每一段分一行

[
    x * y
    for x in range(20)
    for y in range(20)
    if x * y > 200
]
```
### G.FMT.10 代码行的行尾结束符LF和CRLF不应该混用
## 编程实践
### G.TYP.01 需要精确数值计算的场景，应使用decimal模块，且不要用浮点数构造Decimal
```python
# 浮点数无法输出精确结果
print(12.3 * 0.1) # 输出1.2300000000000002
print('{0:.20f}'.format(3.14)) # 输出3.14000000000000012434

from decimal import Decimal

print(Decimal('12.3') * Decimal('0.1')) # 输出1.23
print(Decimal('3.14')) # 输出3.14
```
### G.TYP.02 浮点型数据判断相等不要直接使用==
- 【反例】数学上相等的数字，经过运算后，其浮点数表示可能不再相等
```python
first = 1.0 - 0.8
last = 0.8 - 0.6
if first == last:
    do_something_true() # 预期进入此代码块，执行其他业务逻辑，但事实上data1 == data2的结果在很多情况下可能为False
else:
    do_something_false() # 实际上会进入这里
```
- 【正例】 考虑浮点数的精度问题，可在一定的误差范围内判定两个浮点数值是否相等
```python
first = 1.0 - 0.8
last = 0.8 - 0.6
EPSILON = 1e-15
if abs(first - last) < EPSILON:
    pass
```
- 【正例】Python3.5以后可以使用math.isclose()方法
```python
import math
first = 3.0
last = 2.99998
print(math.isclose(first, last, rel_tol=1e-5)) # 输出结果为True
```
### P.02 合理使用字符串格式化
- 简单的字符串可直接使用+操作，复杂字符串推荐使用.format()方法或f-字符串。
- 避免使用% 进行格式化
```python
# 避免使用%格式化字符串
print('%s%s' % (str1, str2))
print('name: ' + name + '; score: ' + str(score))
```
### P.03 合理使用字符串引号
1. 同一文件内不用单双引号混用
2. 字符串内需要引号的情况使用另外一种引号
3. 多行字符串建议使用三重双引号"""
- 【反例】 在同一个文件中，既有双引号字符串也有单引号字符串，没有保持字符串引号的一致性。
```python
Python("Why are you hiding your eyes?")
Gollum('The lint. It burns. It burns us.')
Gollum("Always the great lint. Watching. Watching.")
```
- 【反例】 当多行字符串是业务逻辑处理的一部分时，不建议在前导三引号之前换行。
```python
std_out = \
"""This is much nicer.
Do it this way."""
```
### G.TYP.03 不要使用难以理解的字面量
- 难以理解的字面量是指通过代码的上下文难以明确业务含义的字面量，包括整型字面量、浮点数字面量、布尔字面量和字符串字面量等。
- 解决途径：
    1. 对于单点使用的难以理解的字面量，按需增加注释说明。
    2. 对于多处使用的难以理解的字面量，应该定义为常量，并通过符号命名自注释。
```python
# 反例
value = 1000 # 不能明确1000代表什么类型
status = 0 # 不能明确0是什么状态
def run():
    prepare("this is a duplicate") # 不符合 ，字符串"this is a duplicate" 多次使用，且难以理解信息
    execute("this is a duplicate")
    release("this is a duplicate")

# 正例
interval_millisecond = interval_second * 1000 # 很容易理解为1秒是1000毫秒

# 下代码中，提取出了能表达含义的常量并通过标识符命名来解释数字含义。
ACTION_ONE = "action_one" # 行为模式1
def run():
    prepare(ACTION_ONE)
    execute(ACTION_ONE)
    release(ACTION_ONE)

# 装饰器中的重复字符串在上下文中是能够理解其含义的，可以不抽取为常量字符串。
@app.route("/api/users", methods=['GET', 'POST', 'PUT'])
def users():
    pass
@app.route("/api/projects/", methods=['GET', 'POST', 'PUT'])
def projects():
    pass
```
### G.TYP.04 建议使用if seq或if not seq的方式判断序列是否为空
- 使用if seq 或if not seq判断序列是否为空，是一种非常Pythonic的编程方式，同时也是PEP8推荐的方式。
- 【反例】
```python
if len(seq):
    pass

if not len(seq):
    pass

if len(seq) == 0:
    pass

if len(seq) != 0:
    pass
```
### G.TYP.05 对序列使用切片操作时，不建议使用负步进值进行切片
- 没见过这么玩的
```python
# 反向切割实属给自己找事
my_list = [1, 2, 3, 4, 5, 6, 7, 8]
print(my_list[-2::-2]) # [7, 5, 3, 1]
print(my_list[-2:2:-2]) # [7, 5]
print(my_list[2:2:-2]) # []
```
- 【例外】a[::-1]是允许的，也是常见操作

### G.TYP.06 同一个字典表达式中各个键值不要相同
- 同一个字典表达式中的各个键值不要重复，如果存在重复的键值，后面的键值对会覆盖前面的键值对，所以应该避免这种情况。
- 实际中这么做也是无意义的
### G.TYP.07 使用dict[key]获取value时需要注意保证key在有效的范围内
- 要防止字典取值可能超出范围的问题，可以做try except处理
- 推荐dict.get(key)方法
- 性能要求不高的场景，可以使用collections模块中defaultdict类
```python
example_dict = dict()
example_key = 'example_key'

try:
    example_value = example_dict[example_key]
except KeyError:
    ... # 符合，对key不存在的情况做异常处理

example_value = example_dict.get(example_key, 'Not exist') # 符合，使用

from collections import defaultdict
example_dict = defaultdict(str) # 符合，使用defaultdict类，默认值为空字符串''
example_key = 'example_key'
print(example_dict[example_key])
```
- 【例外】从代码层面保证使用的key一定在dict存在，那么也可以直接使用[]下标取值。

### G.TYP.08 必须使用isinstance判断变量类型
- **【级别】要求**
- 使用isinstance 代替type 比较来判断变量类型；判断一个对象的类型是否在多个类型中，尽量使用单次isinstance 调用。
- 【反例】
```python
is_integer = type(obj) is type(1)
```
- 【正例】isinstance 不仅会判断对象是否是目标类型的实例，还会判断对象是否是目标类型子类的实例，或者是否能通过目标类型的__instancecheck__校验。
```python
class ABC(type):
    def __instancecheck__(cls, inst):
        return any(cls.__subclasscheck__(c)
            for c in {type(inst), inst.__class__})
    def __subclasscheck__(cls, sub):
        candidates = cls.__dict__.get("__subclass__", set()) | {cls}
        return any(c in candidates for c in sub.mro())


class Integer(metaclass=ABC):
    __subclass__ = {int}

isinstance(1, Integer)
```
### G.TYP.09 建议优先使用语义更明确的内置函数来判断对象的类型或行为
- 大概意思就是，hasatter虽然可以用来判断对象是否有对应特征，但是如果存在内置函数能实现同样功能，则应当优先使用（例如callable()、isinstance()等）
### G.OPR.01 对除法运算和模运算中的除数为0的情况做相应保护
- 【正例】
```python
dividen_num = 0
divisor_num = 0

# 符合，在进行除法运算前，先对除数做非0判断
if divisor_num != 0:
    division_result = dividen_num / divisor_num
    remainder_result = dividen_num % divisor_num
else:
    ... # 其他处理逻辑

# 符合，通过捕获除0异常ZeroDivisionError的方式，来防止程序意外终止
try:
    division_result = dividen_num / divisor_num
except ZeroDivisionError:
    ... # 其他处理逻辑
else:
    ...
```

### G.OPR.02 与None作比较要使用is或is not，不要使用等号
- **【级别】要求**
- is 判断是否指向同一个对象（判断两个对象的id是否相等）， == 会调用__eq__ 方法判断是否等价（判断两个对象的值是否相等）。
```python
# 经典考题
class PersonMetaClass(object):
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender
    def __eq__(self, other):
        if hasattr(other, 'gender'):
            return self.gender == other.gender
        else:
            return 'The assertion property does not exist'

student1 = PersonMetaClass('Xiao li', 17, 'female')
student2 = PersonMetaClass('Han Hong', 18, 'female')
print(student2 is None) # False
print(student2 == None) # The assertion property does not exist
print(student2 == student1) # True
print(student2 is student1) # False
```
### G.OPR.03 禁止使用is或is not运算符在内置类型之间作比较
- **【级别】要求**
- 与上一条相反，内置数据类型之间的比较应该使用==或者!=
```python
from sys import intern

def literal_comparison(param):
    return param == 2000

literal_comparison(2000) # True
literal_comparison(int("2000")) # True
print(() == tuple()) # True
print((1,) == tuple([1])) # True
print(id((1,)) == id(tuple([1]))) # False
```
### G.OPR.04 不建议使用海象运算符
- 不建议使用海象运算符:=

### G.OPR.05 应该使用 is not 运算符而不是not ... is
- 建议使用x is not None 而不是not x is None

### G.OPR.06 应该使用 not in 测试成员关系
- 建议使用x not in the_list 而不是not x in the_list

### G.EXP.01 尽可能使用隐式布尔值
- 以下对象会被看作False：
    - 常量None 和 False
    - 值为0的数值类型：0, 0.0, 0j，decimal.Decimal(0), fractions.Fraction(0,1)
    - 空的序列和容器类型：'',(),[],{},set(),range(0)以及range(8,5)类似的情况
    - 该对象的类定义了__bool__方法，且该方法返回False
    - 否则，该对象的类定义了__len__方法，且该方法返回0
```python
def implicit_false(mydata):
    if mydata:
        pass
    else:
        pass
```
### G.EXP.02 如果lambda表达式的内容超过一行，建议定义为常规函数
- 建议定义为常规函数的场景如下：
    1. lambda表达式的内容较长，例如超过120个字符。
    2. lambda表达式的结构较复杂，例如出现多层嵌套等
        - lambda parameter: exp1 if condition1 else (exp2 if condition2 else exp3)
    3. 标准库operator中已提供的简单运算，不建议再通过重新定义lambda表达式的方法实现。
 
 ### G.EXP.03 不应将lambda表达式赋值给变量，应该使用常规函数
 - 不建议将lambda表达式赋值给变量主要的原因是不便于调试，因为所有的lambda表达式都没有名字，即使将它们赋给变量，在返回的错误堆栈信息中，显示也是<lambda> ，而常规函数在返回的错误堆栈信息中显示的是该函数的名字。
 
### G.EXP.04 推导式和生成器表达式仅用于简单的逻辑表达
- 列表、字典、集合推导式和生成器表达式均只能在简单的场景下使用：各部分只能占一行，不建议使用过于复杂的推导式

### G.CTL.01 同一个函数所有分支的返回值类型和个数保持一致
- 分支返回值类型数目变化会导致调用者难以处理，以及隐藏风险
- 可以返回None，但不能昨晚内置类型的同类
- 【反例】 下面的函数都包含if 条件分支，但多分支的返回对象类型不一致。
```python
def function_with_no_else_return_statement(x):
    if x >= 0:
        return x + 1
def function_return_type_inconsistent(x):
    if x < 0:
        return
    return x + 1
```
- 【正例】
```python
INVALID_VALUE = -1


def function_with_return_statement(x):
    if x >= 0:
        return x + 1
    else:
        return INVALID_VALUE
        
def function_return_type_consistent(x):
    if x < 0:
        eturn INVALID_VALUE
    return x + 1
```
