科目四真题（0301答案澄清）
1、在周期性数据校验模型中，为了删除备数据库的多余数据，必须使用哪一种校验方法：（B）
A.	正向校验
B.	反向校验
C.	正向和反向校验
D.	水平校验
2，下面哪个 UML视图是描述一个对象的生命周期的(A ）
A顺序图B状态图C对象图D部署图
3,在需求分析活动中，下面哪种做法容易引起某环节信息传递缺失或需求理解出现偏差()
A.	将需求以测试用例的方式呈现，并尽早验证
B.	SE独立进行需求分析，并严格按照流程输出需求分析文档，开发人员根据此文档进行下一步设计和开发
C.	客户、MKT、SE、TSE等一起参与需求的分析制定，并通过实例场景来说明
D.	采用GWT（Given-When-Then），数据表格等格式来描述需求的场景或实例
4,对系统的重要操作记录日志是满足安全审计的基本要求，以下哪个做法不符合日志审计要求的：ABC
A.	系统提供普通账号删除日志功能，可删除仅与自己账号相关的日志记录
B.	调试日志中可以记录口令类信息
C.	用户的权限变更可以不记录日志
D.	日志记录字段包含用户ID、时间、访问发起端地址或标识、事件类型、被访问的资源名称，事件结果等。
5, 总体与局部关系  D
A. 泛化 B. 依赖 C. 实现 D. 聚合
6,1个父类 
7,某软件公司 
8,基于用例
 
9,

单点故障模型分析方法及影响：（AB）
A、I类：导致整个系统崩溃或主要功能受到严重影响
B、II类：导致系统主要功能受到影响、任务延误的系统轻度损坏或存在较大的故障隐患
C、III类：导致系统次要功能丧失或下降，须立即修理，但不影响系统主要功能实现的故障
D、IV类：导致部分次要功能下降，只须一般维护的，不对功能实现造成影响
下面哪些场景可以应用
 
针对重构方法
 


3、需求管理方法，包括需求优先级排序方法、变更管理流程控制、需求验收策略等 （C）
A.
需求分析输出的质量准则包括完整性，正确性，可验证性和一致性
B.
需求的变更需要进行规范的流程管控，应根据需求排序及时拒绝低优级的需求，减少后继的方案设计及开发工作量
C.
软件项目唯一不变的就是不断变更，在需求分析过程中，无法做到面面俱到，在版本开发过程中，一旦客户需求发生变化，我们应及时发起CR变更，更新系统需求状态，尽可能满足客户需求
D.
需求管理最基本的任务是明确需求，使项目团队和用户达成共识，即建立需求基线
4、身份和访问控制管理安全设计 （D）
A.
串口
B.
USB接口
C.
管理网口
D.
电源口
5、可信设计模式 （A）
A.
容器入侵检测系统，采用事件驱动机制，基于audit和inotify等OS模块对容器行为进行深度分析，识别容器内发生的攻击行为和异常行为
B.
入侵检测防御系统，支持特征识别。基于应用识别特征库可识别P2P、IM、网络游戏等6000+种应用协议，进行阻断、流量限制、应用使用情况展示等处理
C.
系统部署入侵检测功能，可以监控TCP、UDP、ICMP通信，支持自定义签名（特征码）应对攻击
D.
入侵检测防御系统，支持高效的病毒防御。基于签名库（特征码）检测PE、蠕虫、木马、病毒、恶意程序、跨站攻击、SQL注入等
6、设计模式的分类、实现与应用 （D）
A.
命令（Command）模式
B.
观察者（Observer）模式
C.
代理（Proxy）模式
D.
责任链（Chain of Responsibility）模式
7、通用设计原则 （C）
A.
企鹅不支持“飞行”方法，继承鸟这一关系不符合依赖倒置（Dependency Inversion）原则，应该将“飞行”行为从鸟类的定义中分离出来，定义为接口，大雁对该接口进行实现
B.
企鹅不支持“飞行”方法，继承鸟这一关系不符合里氏替换（Liskov Substitution）原则，应该把鸟类的定义复制一份，复制出来的定义去掉飞行方法，让企鹅继承这个新的类
C.
企鹅不支持“飞行”方法，继承鸟这一关系不符合里氏替换（Liskov Substitution）原则，应该将“飞行”行为从鸟类的定义中分离出来，定义为接口，大雁对该接口进行实现
D.
企鹅不支持“飞行”方法，继承鸟这一关系不符合依赖倒置（Dependency Inversion）原则，应该把鸟类的定义复制一份，复制出来的定义去掉飞行方法，让企鹅继承这个新的类
8、软件需求分析的原则与基本流程 （A）
A.
数据支持FTP协议传输
B.
数据采集性能提升10%左右。
C.
设备支持温度、功耗等信息实时统计
D.
支持新老特性兼容
10、需求分析需要关注的场景和维度（功能/质量/约束/DFX需求） （C）
A.
客户、MKT、SE、TSE等一起参与需求的分析制定，并通过实例场景来说明
B.
将需求以测试用例的方式呈现，并尽早验证
C.
SE独立进行需求分析，并严格按照流程输出需求分析文档，开发人员根据此文档进行下一步设计和开发
D.
采用GWT（Given-When-Then），数据表格等格式来描述需求的场景或实例
11、识别代码坏味道 （D）
A.
引入解释性变量（Introduce Explaining Variable），消除过长函数（Long Method）的坏味道
B.
将函数使用的注册基本信息相关的参数聚合成一个对象User，解决用户注册信息逐渐增多带来的霰弹式修改（Shotgun Surgery）问题
C.
通过引入参数对象（Introduce Parameter Object），把register方法过多的的方法参数封装成一个或几个对象，消减过长函数（Long Method）的坏味道
D.
通过以多态取代条件式（Replace Conditional with Polymorphism）的手法将不同角色的注册逻辑独立出来，消除过长函数（Long Method）的坏味道

13、掌握重构手法 （A）
A.
如果大多数子类都覆写了父类的同一个函数且实现相同，此时该函数上移到父类中去作为这个函数的默认实现可以减少重复。
B.
如果各个子类中都有一个完全相同的函数，但不同子类中的函数处理上有些许差异，此时最好把这些函数上移到父类中，在父类中识别差异分别处理不同场景的逻辑，同时把各子类中的函数予以删除。
C.
如果在同层的各个子类中，有一部分子类的成员变量有相同或近似的名字，最好把这些成员变量上移到其共同的父类中。
D.
父类中存在一些成员变量在部分子类中没有意义，并不影响代码功能，多余一些成员变量不会造成问题，不需要下移到子类中。
15、特性威胁分析方法 （A）
A.
泛洪（Flooding）
B.
模糊测试（Fuzzing）
C.
仿冒（Spoofing）
D.
中间人（Man in the middle）
16、安全红线 （C）
A.
允许产品根据正常业务的需要，采集、处理、存储个人数据，但必须提供必要的安全保护机制，以防止个人数据被泄漏、丢失、破坏
B.
必须在产品资料中对产品涉及用户隐私的功能进行描述和免责
C.
为保护个人隐私，禁止出于问题定位的目的，采集并分析系统中的个人数据
D.
如需将问题定位数据传出EEA（European Economic Area），必须对其中的个人数据进行过滤、或匿名化或假名化处理
17、UML建模 （A）
A.
S类与P类的继承关系中不能指定多重性（1..*）
B.
S类与P类的聚合关系中不能指定多重性（1..*）
C.
S类与P类已经有继承关系，不能再存在聚合关系
D.
S类不能与P类有重复的成员函数show
18、特性威胁分析方法 （B）
A.
涉及到认证鉴权等安全机制的场景
B.
涉及到个人数据传输的场景
C.
涉及到业务敏感数据传输的场景
D.
涉及到金钱交易的场景
19、掌握重构手法 （B）
A.
一个复杂的条件（if-then-else）语句，从if、then、else 三个段落中分别提炼出独立函数，可以更清晰的表达自己的意图
B.
在一系列多个条件处理中，有时会在前面的条件中设置临时变量用来控制后面的条件走入特定分支，这种“控制标志”即使有助于理解代码意图也应该消除
C.
如果有的条件语句（if-then-else）成立的then分支会做大量的主要流程处理或者有多层条件语句嵌套，else分支则只做了少量处理就返回或跳出函数，可以单独检查这些条件不成立时提前返回或跳出（这种方法也叫卫语句），这样可以减少嵌套并将使代码更清晰
D.
一系列的条件测试结合起来表示一个完整的概念（比如多个体检指标超标结合起来表示肥胖），可以将这些条件合并为一个条件式，并将这个条件式提炼为一个独立的函数，这样可以使条件更清晰
20、识别代码坏味道 （C）
A.
通过封装变量（Encapsulate Variable），将declare的方法参数封装成多个对象，从而减少方法参数个数： ```java boolean declare(PersonalInfo personalInfo, String familyMembers, Address address, Bringing bringing, HealthInfo healthInfo) { // 省略实现... } ```
B.
将健康信息以如下方式追加到方法declare的方法参数中： ```java boolean declare(String familyName, String firstName, String middleName, int month, int day, int year, String familyMembers, Address address, String street, String city, String state, boolean isFruitsBringing, boolean isMeatBringing, Boolean isSoilBringing, Boolean isHeat, Boolean isFromHighRiskArea, Boolean isDetected) { // 省略实现... } ```
C.
通过引入参数对象（Introduce Parameter Object），把declare的方法参数封装成一个或几个对象，解决过长参数列表（Long Parameter List）的坏味道： ```java boolean declare(PersonalInfo personalInfo, String familyMembers, Address address, Bringing bringing, HealthInfo healthInfo) { // 省略实现... } ```
D.
通过改变函数声明（Change Function Declaration）的方式，将declare的方法参数封装成多个对象，从而减少方法参数个数： ```java boolean declare(PersonalInfo personalInfo, String familyMembers, Address address, Bringing bringing, HealthInfo healthInfo) { // 省略实现... } ```
22、身份和访问控制管理安全设计 （C）
A.
敏感功能的开启，比如端口镜像
B.
身份认证凭证即将过期或已过期
C.
业务模块加载失败
D.
连续登录认证失败达到系统设定的次数
24、可信设计模式 （B）
A.
自主访问控制模式
B.
多级安全模式
C.
访问控制列表模式
D.
身份联合模式
25、故障模式分析方法及影响 （C）
A.
是否涵盖了所有的功能子模块的主要故障模式
B.
是否考虑了自动恢复等对严酷度等级的影响
C.
是否从设计师的角度来进行定义
D.
是否考虑了最坏潜在后果

29、设计模式的分类、实现与应用 （C）
A.
外观（FACADE）模式
B.
观察者（OBSERVER）模式
C.
策略（STRATEGY）模式
D.
组合（COMPOSITE）模式
36、安全红线 （BCD）
A.
日志记录字段包含用户ID、时间、访问发起端地址或标识、事件类型、被访问资源的名称、事件结果等
B.
调试日志中可以记录口令类信息
C.
系统提供普通账号删除日志功能，可删除仅与自己账号相关的日志记录
D.
用户的权限变更可以不记录日志
37、特性威胁分析方法 （ABCD）
A.
管理员可以任意删除日志
B.
为日志分配的空间能够存储3天的日志，日志满后绕接
C.
对于支持同一用户多点登陆的情形，日志中不记录IP地址
D.
系统打补丁操作不记录日志
38、设计模式的分类、实现与应用 （AB）
A.
观察者（Observer）模式
B.
状态（State）模式
C.
适配器（Adapter）模式
D.
桥接（Bridge）模式
39、识别代码坏味道 （ACD）
A.
测试无法捕捉所有bug，所以写测试代码没有价值，重构时不需要考虑补充测试代码
B.
重构是指使用一系列重构准则和方法，在不改变软件可见行为的前提下，调整其结构，提高其可维护性，降低修改成本
C.
重构是设计阶段的事情，开发人员开发代码是只要正确实现功能就可以了，设计时如果没有要求就不用考虑重构代码
D.
重构增加了额外的开发工作，会影响编程速度，所以会降低效率
41、识别代码坏味道 （ABC）
A.
通过提炼类（Extract Class）的方式，将case语句中关于“栏目关键字”的校验抽象成单独的类，使得该类可以根据栏目的要求指定具体的关键字范围
B.
通过引入参数对象（Introduce Parameter Object），把参数封装成一个或几个对象，可以有效解决代码中过长参数列表（Long Parameter List）的坏味道
C.
运用提炼函数（Extract Method）将处理“美食栏目文章校验”的case语句提炼到一个独立函数中，再以搬移函数（Move Method）将它挪移到经过多态改造的FoodChecker类中，通过以多态取代条件式（Replace Conditional with Polymorphism）的手法将不同栏目的审核逻辑独立出来。
D.
引入解释性变量（Introduce Explaining Variable），降低圈复杂度和过长函数（Long Method）等坏味道
43、通用设计原则 （BD）
A.
为了与老特性隔离，对于所有需要修改的代码文件，拷贝一份新文件并改名，然后在新文件上进行修改作为新特性代码使用
B.
使用单独的文件或者函数实现新功能业务，然后在业务调用点调用新业务提供的接口
C.
找到需要插入新代码的多个地方，拷贝原有的类似代码过来，直接进行对应的修改
D.
如果新增业务是一个单独的可以裁减或者卸载的特性，采用特性隔离手段来实现这个新需求


