题干	选项	答案
下列关于python中的闭包，错误的是	
A. 某个函数被当成对象返回时，夹带了外部变量，就形成了闭包
B. 闭包常用在装饰器函数中，装饰器需要自定义参数时，一般都会形成闭包
C. 闭包中是可以修改外部作用域局部变量的"	C

保护项目未来可维护性的一种理想方式，以下哪些工具可以辅助完成	
A.PyLint
B.Flake8
C.Autopep8
D.Coverage
E.Yapf
F.cProfil
G.PyGame"	ABCDE

以下哪种工具能帮你自动检查代码问题，使其符合PEP8规范（多选）	
A. Coverage;
B. Flake8;
C. Yapf;
D. Autopep8"	BCD

下列有关pylint，正确的说法是	
A. too many instance attributes中规定类属性不得多于7个
B. too many arguments告警可通过dict、class等方式来消除
C. deprecated-lambda告警的消除做法是，引用列表推到来代替map和filter
D. 当遍历涉及范围和索引时，尽量使用enumerate代替range"	ABCD

当应用到已经排好序的数组上去时，哪个算法复杂度最低？	
A 快速 
B 希尔 
C 归并 
D 插入"	D

假设整数数组 A[n]中的数都介于 1 到 n^6 之间， 下述什么算法有 O(n)的时间复杂度	
A. 没有任何算法 
B. 基数排序 
C.计数排序 
D.快速排序"	B

关于模块公共API的设计，以下哪些说法为业界广泛应用的“pythonic”编程习惯	
A. 任何向后兼容性保证仅适用于公共接口，因此，用户是否能够清楚得区分公共和内部接口时很重要的。
B. 为了更好地支持内省，模块应使用__all__属性在其公共API中显示声明名称。将__all__设置为空列表表示该模块没有公共API。
C. 如果有__all__属性的存在，内部接口就不需要前导下划线为前缀的写法了。
D. __all__规定了模块所有的公共API，不在__all__之内的对象无法被外部模块使用import的方法引入。"	AB
哈希表有14个桶， h(key)=key%11,现有18,37,55,61,79， 如果用二次探测再散列处理冲突，则39位于第（D）个桶内。	
A.6 
B. 8 
C. 4 
D. 10"	D

哈希表有14个桶，哈希函数为h(key)=key%11。表中现有数据30、48、66、18、72和90，如果分别采用线性探测法和二次探测再散列处理冲突，则28的位置（从0开始计数）可能是（）	
A. 9
B. 10
C. 11
D. 12"	AB

如下哪个代码符合公司的编码规范要求与建议（）	
A. """""" today is a nice day
I think 123 is a lucky number """"""
B. index += 1 # 递增索引编号
C. total_age = wife_age + husband_age
D. index_num+=1
E. if result == None:
        print(""success"")"	C
下列哪些事件应该记录在运行日志中	
A. 服务挂载硬盘失败
B. 服务启动、服务停止
C. 配置文件加载成功/失败
D. CPU、内存和硬盘的过载和恢复信息"	ABCD
下列哪些事件应该记录在运行日志中	
A. 操作维护人员发起的对云服务的部署、升级、配置、更新、扩缩容等维护操作
B. 定时/自动任务发起的对云服务的配置、更新、创建VM、删除VM等维护操作
C. 用户（指系统管理员、操作维护员、系统监控员等）登录、注销和鉴权等
D. 对敏感信息例如话单、账单、用户的银行卡信息、余额信息、位置信息等的访问等"	ABCD
哪个代码执行效率最慢	
A.
1.s1, s2 = 'Xi', 'Gua'
2.'hi, %s%s' %(s1, s2)
B.
1.s1, s2 = 'Xi', 'Gua'
2. 'hi,{0}{1}'.format(s1,s2)
C.
1.s1, s2 = 'Xi', 'Gua'
2. 'hi' + s1 + s2"	B
可迭代对象必须实现哪些方法	
A. __iter__()
B. __super__()
C. __next__()
D. __reduce__()"	A
已知一棵7层完全二叉树的第六层（设根为第一层）有7个叶节点，则该完全二叉树的节点个数最多是（）	
A. 38
B. 51
C. 113
D. 120"	C
关于软件工程，以下说法错误的是	
A. 软件工程是一个工程学科，涵盖了软件生产的各个方面，从出事的构想到运行和维护
B. 软件工程是指实现软件生产开发的活动序列
C. 软件工程的目的是支持专业特化的软件开发，而非个人编程
D. 软件工程发展的目的就是希望找到一种合适的方法和技术运用于软件系统"	B
对于需求管理，理解不正确的是	
A. 纯软件需求决策由软件RMT负责
B. 产品软硬件结合需求决策由对应产品SPDT RMT负责
C. 需求冲突时可在CCB会议仲裁
D. 产品RAT负责各个产品系列的软硬结合需求分析"	C
关于局部变量的作用域，如下代码的输出是什么	
```python
def hande(x):
    do something here
    ...
i = 3
def foo(x):
    def bar():
        return i
    for i in x:
        handle(x)
    return bar()
i = 3
def foo_1(x):
    def bar():
        return i
    y = [i for i in x]
    handle(y)
    return bar()
print("%s,%s"%)
```
A.y,3	A
有一个 UTF-8 编码的文件，需要转码成 GBK 编码的文件，操作流程正确的是	
decode(‘utf-8’) —>encode(‘gbk’)，	

以下是字符转换成字节的方法是	
A. decode()
B. encode()
C. upper()
D. rstrip()"	B

关于元类，下列描述正确的是	
A. 元类是类的类，常可以用在类工厂中； 
B. Python中所有的类都是对象，可以通过type( )来创建元类
C. 在定义类时，可用过metaclass参数来指定此类的元类
D. Python类语句执行时，会先查找其类本身的metaclass属性，如果没找到，会继续在父类中找，还没找到，则到模块中找，最后再用内置的type来创建此类对象
E. 使用类、函数都可以当做元类，通常在new()方法中通过type来自定义自己的元类
F.  从设计的复杂度来讲，尽量少用元类，多用普通类或函数"	ABCDF

关于面向对象编码，下列说法正确的是	
A. 对于类的公有属性，不应该在名称前加下划线
B. 对于简单的类公有变量，最好不要设置过多的getter/setter，直接访问即可
C. classmethod首选使用cls拼写作为第一个参数的名称
D. 避免使用属性进行计算成本高昂的操作"	ABCD

某软件用户注册界面要求输入用户名和密码，用户名和密码都限定为7~10位数据和字母的组合，若用等价类划分设计测试用例，则（）符合等价类设计要求	
A. (用户名，密码) = (Abc123, abcD1238)
B. (用户名，密码) = (!123, 123ABcde)
C. (用户名，密码) = (1234Ab, !Ac1234)
D. (用户名，密码) = (@123adc, 123iopA)"	ABD

下列关于序列化和反序列化说法正确的是（）	
A. 禁止对不可信来源的数据进行unpickle和load shelf
B. 将敏感对象发送出信任区域前只需进行签名，不需要进行加密操作
C. 禁止序列化未加密的敏感数据
D. 因为shelf依赖于pickle，所以不可信来源的laod shelf也是不安全的"	ACD

下列哪些描述是符合安全编程规范的	
A. 禁止在日志中保存口令、密钥和其他敏感信息
B. 禁止使用私有或者弱加密算法
C. 基于哈希算法的口令安全存储必须加入盐值（salt）
D. 禁止将敏感信息硬编码在程序中
E. 禁止使用SSLSocket来进行安全数据交互"	ABCD

（多选）禁止采用如下哪些算法进行口令加密（）	
A. RSA
B. DES
C. SKIPJACK
D.MD5"	BCD

可以用作python模块搜索路径的是	
A. sys.path 指定的路径列表
B. 环境变量PYTHONPATH指定的相关路径
C. 环境变量PATH指定的相关路径
D. Python标准库"	ABD

str_list为多个字符串的列表，内存最少，不考虑时间，优先使用拼接方式（）		B
 代码覆盖率最高的是	
A. 语句覆盖
B. 判定覆盖
C. 条件覆盖
D. 组合覆盖"	D

"下面代码 print(a, b) 输出
a = 1
b = 2
a,b = b,a
print(a,b)"	
A. 1 2
B. 2 1
C. 错误
D. 2 2"	B

下面代码输出
"class GrantParent:
    def __init__(self):
        print('Hello GrantParent.')

class Parent(GrantParent):
    def __init__(self):
        super().__init__()
        print('Hello Parent.')

class Child(GrantParent, Parent):
    def __init__(self):
        super().__init__()
        print('Hello Child.')
        
c = Child()"	
A. Cannot create a consistent method resolution order (MRO) for bases GrantParent, Parent
B.
GrantParent.__init__()
Parent.__init__()
Child.__init__()
C.
GrantParent.__init__()
GrantParent.__init__()
Parent.__init__()
Child.__init__()
D.
GrantParent.__init__()
GrantParent.__init__()
GrantParent.__init__()
Parent.__init__()
Child.__init__()"	A

关于公网地址，下面的是不正确（）	
A. httplib.HTTPConnection('www.python.com')
B. urllib.open('https://www.huawei.com')
C. ftp=FTP('ftp.debian.org')
D. test_sites = read_from_file() "	ABC

日志记录正确的是（）	
A. 日志中禁止记录口令、密钥等敏感信息
B. 特殊原因必须要记录日志，应该使用固定长度的星号（*）代替口令、密钥等敏感信息
C. 日志不可以记录明文口令，但可以记录加密后口令
D. 日志可以随便记录"	AB

8核CPU下仅使用threading库，CPython解释器下同一时刻最多有（）个线程执行	
A. 1
B. 2
C. 4
D. 8"	A

仅允许80、8000、8080端口通过，等价类测试时有效等价类和无效等价类有	
A. 4,1
B. 3,1
C. 3,2
D. 4,2"	B

"某系统有三个输入A,B,C，每个输入的取值个数分别为4,6,7，使用EC（单一选择组合）方法设计测
试用例，至少需要设计多少个用例（）"	
A. 3
B. 7
C. 15
D. 17"	B

数据组合测试，用例个数最少的是	
A. EC（单一选择组合）
B. BC（基本选择组合）
C. AC（全组合）
D. Pair-wise"	A

路径检查，正确的是	
A. os.normalpath('/home/python/xxx')
B. os.realpath('/home/python/xxx')
C. os.abcpath('/home/python/xxx')
D. '/home/python/xxx'.startwith()"	B

正确的是	
A. 禁止对不可信来源的数据进行unpickle和load shelf
B. 将敏感对象发送出信任区域前只需进行签名，不需要进行加密操作
C. 禁止序列化未加密的敏感数据
D. 因为shelf依赖于pickle，所以从不可信来源的数据load shelf也是不安全的"	ACD

下面正确的是	
A. {('a'): 1} == {('a',): 1}
B. {'a': 1, 'b': 2} == {'b': 2, 'a': 1}
C. {1: 1, 2: 2} == dict({2: 2, 1: 1})
D. {} == dict()"	BCD

下面正确的是	
A. 'β' > 'α'
B. 'A' == 'a'
C. 'A' + 'a' == 'a' + 'A'
D. 'a' * 2 == 2 * 'a'"	AD

print(7 % (7 // 3)) 输出	
A. 1
B. 2
C. 1.0
D. 2.0"	 A

{1, 2, 3, 4, 5} ^ {5, 6} 结果是	
A. {1,2,3,4}
B. {1,2,3,4,5,6}
C. {1,2,3,4,6}
D. {6}"	C

print(int('1' + '2') + 2) 输出	
A. 14
B. 2
C. 错误
D. 5"	A

print(eval ('2+4'))	
A. eval (‘2+4’)
B. 6
C. ‘2+4’
D. 错误"	B

下面代码输出
"class Next:
    def __init__(self):
        self.data = [0, 1, 2, 3, 4]
        self._iter = iter(self.data)

    def __iter__(self):  # 被内置方法iter()调用或者for item in container时调用, 要在__iter__中return self
        return iter(self.data)

    def __call__(self, *args, **kwargs):  # 使类对象可以像函数一样调用, object()
        return next(self._iter)

    def __next__(self):
        return next(self._iter)


for i in iter(Next(), 3):
    print(i)"	
A.
0 1
B.
0 1 2
C.
0 1 2 3
D.
0 1 2 3"	B

下面代码输出	
result = [1,2,3,4,5]
result[1:3] = 'abc'
print(result[2])
A. ‘a’
B. ‘b’
C. 3
D. ‘abc‘"	B

下面代码输出	
funcs = []
for i in range(4):
    def closer_func(x):
        return x*i
    funcs.append(closer_func)
print([m(2) for m in funcs])
A. [6, 6, 6, 6]
B. [0, 1, 2, 3]
C. [0, 2, 4, 8]
D. [0, 2, 4]"	A

print([(lambda x:i*x)(2) for i in range(5)])		 [0, 2, 4, 6, 8]

下面代码输出
class ReadOnlyDict(dict):
    def __init__(self, *args, **kwargs):
        super(ReadOnlyDict, self).__init__(*args, **kwargs)
        self._read_flg = True

    def __read_only_limit__(self):
        if self._read_flg:
            raise AttributeError(""ReadOnly"")

    def __setitem__(self, key, value):
        self.__read_only_limit__()
        super(ReadOnlyDict, self).__setitem__(key, value)

    def __delitem__(self, key):
        self.__read_only_limit__()
        super(ReadOnlyDict, self).__delitem__(key)


d = ReadOnlyDict({1: 1, 3: 3})
d.update({3: 3})
print(d)  
print(d.pop(3))  
d[4] = 4"	
A. AttributeError: ReadOnly
B.
{1: 1, 3: 3}
AttributeError: ReadOnly
C.
{1: 1, 3: 3}
3
AttributeError: ReadOnly
D.
{1: 1, 3: 3}
3"	C

"如下代码能输出 1 2 的有
def fun():
    yield 1
    yield 2"	
A.
print(fun())
print(fun())
B.
mf1 = fun()
it1 = iter(f1)
print(next(it1))
print(next(it1))
C.
for i in fun():
    print(i)
D.
a = fun()
print(next(a))
print(next(a))"	BCD

看Cprofile的结果,分析哪个方法需要优化:
[Ruby@pekphispra59074 generated_script]$ python -m cProfile ./time_consume_task.py 
         204 function calls in 1.007 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    1.007    1.007 time_consume_task.py:1(foo1)
      100    0.800    0.000    0.807    0.010 time_consume_task.py:4(foo2)
        1    0.000    0.000    0.007    1.007 time_consume_task.py:8(main)
        1    0.000    0.000    0.000    0.000 time_consume_task.py:10(foo3)
        1    0.000    0.000    0.000    0.000 {range}
      100    1.006    0.010    1.006    0.010 {time.sleep}....."	
A. foo_0
B. foo_1
C. foo_2
D. foo_3"	C

下面代码不符合华为规范的是	
items = ["1223",12,"1234",412]
items = [item for item in items if type(item) == str]
if items != []:
    do_something(items)

A. 第1行
B. 第2行
C. 第3行
D. 第4行"	BC

"entities中的对象，只会被遍历一次，且不需要长期持有（B）
class Entity
    def __init__(self, eid=0)
        self.__eid = eid"	
A.
entities = [ Entity(i) for i in range(1000)]
B.
entities = (Entity(i) for i in range(1000))
C.
entities = []
for i in range(1000):
entities.append(Entity(i))
D.
entities = [None] * 1000
for i in range(1000):
entities.append(Entity(i))"	B

"进入pdb调试模式后，下列说法正确的是：( C )
import sys
import os
x = 1
y = 9
z = x + y
def func1():
  pass
def func2():
  print('func1 is called')
func2()"	
A.进入pdb调试模式后，代码执行位置会停在func2()这一行
B.进入pdb调试模式后，代码执行位置会停在x=1这一行
C.进入pdb调试模式后，代码执行位置会停在import sys这一行
D.进入pdb调试模式后，代码执行位置会停在def func1()这一行"	C

以下哪项不适合写在注释中	
A、变更记录
B、性能瓶颈
C、设计原理
D、线程是否安全"	A

使用UDP协议通信时，需要使用哪个类把要发送的数据打包?	
A. SocketCmt
B. DatagramSocket
C. DatagramPacket
D. ServerSocket"	C

下述哪个选项的代码符合《华为Python语言编程规范》 中“变量作用域”章节的要求和建议		BD
A.
def func():
    global acc
    acc = 2
B.
_acc = 1
def func():
    print(_acc)
func()
C.
_acc = 1
def func():
    global _acc
    print(_acc)
func()
D.
_acc = 1
def func():
    global _acc
    _acc = "None"
func()
print(_acc)

下面调用库方法不正确的是	
A. from os import path
B. import importlib
    path = importlib.import_module('os.path')
C. import os.path
D. path = __import__('os.path')"	D

虚拟环境管理工具tox的多版本兼容测试,配置如下:
[tox]
envlist = {py36,py27}-django15"	
A.表示1个环境,使用python3.6或者python2.7
B.表示2个环境,py27-django15环境的python版本只能是python 2.7，py36-django15的python版本只能是python 3.6
C 
D表示2个环境, 使 用 python3.6和python2.7，如果后面配置了basepython字段，环境的python版本由basepython指定；否则，由环境名中的pyxx来决定"	D

SQL注入是指后台数据库对用户输入数据的合法性没有判断或者过滤不严，攻击者可以在web页面中插入额外的SQL语句，实现对后台数据库的非法访问操作。以下关于SQL Injection（SQL注入）的说法错误的是哪个？	
A. SQL Injection安全漏洞可以攻击系统数据库，篡改数据库数据和获取未授权的信息。
B. SQL Injection可以通过危及客户端安全，来盗取用户个人敏感数据。
C. SQL Injection主要是来自用户或者外界的非信任源的数据在进行SQL查询时，没有过滤或者过滤不完备，外部字符串包含特定字符，改变了原来语句的查询本意。
D. SQL Injection安全漏洞可以通过安全的输入校验机制来预防。"	B

关于随机数的描述，错误的是（）	
A. 真正意义上的随机数其结果是不可预测的，安全随机数并非真正意义上的随机数
B. 现代密码学是基于密钥安全的，随机数的质量决定密钥的质量
C. C标准函数random()所产生的随机数不属于安全随机数
D. 安全随机数的要求是不可预测、绝对安全"	D 

基于《密码算法应用规范》,下列哪种随机数生成方式自身会出现安全漏洞？	
A. Linux操作系统的/dev/random设备接口
B. OpenSSL1.1.X的RAND_priv_bytes
C. NIST SP 800-90A标准中的DualEC-DRBG生成器
D. JDK的java.security.SecureRandom"	C

以下哪些选项符合《华为Python语言编程规范》中“异常处理”章节的要求和建议（CDE）	
A.
import contextlib
class Example(contextlib.AbstractContextManager):
    def __exit__(self,exc_type, exc_value,tracback):
        ...
        return 1
B.
import contextlib
class Example(contextlib.AbstractContextManager):
    def __exit__(self,exc_type, exc_value,tracback):
        ...
        return exc_type(exc_value)
C.
import contextlib
class Example(contextlib.AbstractContextManager):
    def __exit__(self,exc_type, exc_value,tracback):
        return True
D.
import contextlib
import time

class Example(contextlib.AbstractContextManager):
    def __init__(self):
        self.start = 0
    
    def __enter__(self):
        self.start = time.time()

    def __exit__(self,exc_type, exc_value,tracback):
        print("Running cost seconds",time.time() - self.start)
E.
import contextlib

class Example(contextlib.AbstractContextManager):
    def __exit__(self,exc_type, exc_value,tracback):
        ...
        return exc_type(exc_value)
CDE


Python3.8版本中，下列哪些选项符合《华为Python语言编程规范》中“数据安全处理”章节的要求和建议（）	
A. os.urandom 在linux系统环境中生成的随机数不可用于安全加密目的。
B. os.urandom 在windows系统环境中生成的随机数不可用于安全加密目的。
C. os.urandom 在linux系统环境中生成的随机数可用于安全加密目的。
D. os.urandom 在windows系统环境中生成的随机数可用于安全加密目的。"	CD

内置函数dir()的作用是（）	
A. dir()函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。
B. dir()函数不带参数时，列出当前目录的所有文件，带参数时，列出指定目录下所有文件。
C. dir()函数判断指定的参数是否为目录。
D. dir()函数判断指定的参数是否为文件。"	A

logging模块提供日志功能，默认情况下，如下哪种说法是正确的（）	
A. 默认情况下，logging模块将日志打印到屏幕（stdout），日志级别为WARNING级以上的才输出
B. 默认情况下，logging模块将日志打印到文件log.log，日志级别为WARNING级以上的才输出
C. 默认情况下，logging模块将日志打印到文件log.log，所有日志级别的信息都输出
D. 默认情况下，logging模块将日志打印到屏幕（stdout），所有日志级别的信息都输出"	A

如下哪个代码不存在SQL注入风险		C
C:
sql = "SELECT * FROM table WHERE id=?"
connecton.execute(sql,(value,))

下面哪一项是避免SQL注入攻击的推荐做法（）	
A. 使用预处理语句或参数化查询创建动态查询
B. 使用MySQLdb或SQLAIchemy，在用户环境中以最大权限执行查询
C. 将用户输入设置为正确类型，再在数据库中直接引用任意表格
D. 在将参数作为元组向execute()函数传递前，使用黑名单验证并辅以参数转义"	A

关于序列非空判断，如下哪个符合PEP8规范（）		A
A:
if not seq:
    pass

在unitest单元测试框架中，通过TextTestRunner类的run方法，提供了丰富的执行策略和执行结果，run()方法的入参可以是如下哪些类的对象（）	
A. TestCase
B. TestSuit
C. TestRunner
D. TestResult"	AB

"result = {i*2 for i in [1,2,3]}
print(type(result))"		
答案:
<class 'set'>

"value = set([1,2,3,4])
for num in value:
    value.remove(num)
print(value)"	
答案:
RuntimeError: Set changed size during iteration

class A:
    x = 0

a = A()
a.x = 1

print(a.x, A.x) # 1 0

class A:
    x = 0

a = A()
A.x = 1

print(a.x, A.x) # 1 1

class A:
    x = 0

a = A()
a.x = a.x
A.x = 1

print(a.x, A.x) # 0 1


item = ["hello"]
items = [item] * 3  # 乘 3 之后得到的是一个 3行, 1列的二维数组, 而不是个1行3列的数组
print(items)  # [['hello'], ['hello'], ['hello']]
items_1 = item * 3  # 乘 3 之后得到一个 1行, 3列的一维数组
print(items_1)  # ['hello', 'hello', 'hello']
items[0][0] = "world"
print(items)  # [['world'], ['world'], ['world']]
items_1[0] = "world"
print(items_1)  # ['world', 'hello', 'hello']
# print(items[0][1]) # IndexError: list index out of range
# print(items[0][2]) # IndexError: list index out of range
print(items[0][0]) # world
print(items[1][0]) # world
print(items[2][0]) # world

result = {i * 2 for i in [1, 2, 3]}
print(type(result)) # "<class 'set'>
print(result)       # {2, 4, 6}
# 通过[] 括起来的推导式, 返回的是列表
result = [i * 2 for i in [1, 2, 3]]
print(type(result)) # <class 'list'>
print(result)       # [2, 4, 6]
# 用括号括起来的推导式, 返回的是生成器函数(对象), 不是tuple, 需要通过循环遍历, 或者list()
# 通过循环只能迭代一个轮次
# 生成器函数不用常驻内存,临时用的时候取出来. 考虑性能的场景下推荐使用
result = (i * 2 for i in [1, 2, 3])
print(type(result)) # <class 'generator'>
print(result)       # <generator object <genexpr> at 0x0000024E5FA7B5A0>
for i in result:
    print(i)		
"""
2
4
6
"""

import copy
l1 = [[1], 2.3]
l2 = l1
print(id(l2) == id(l1)) # True
l2 = copy.copy(l1)
l2[0][0] = 2
print(l1)               # [[2], 2.3]
print(id(l2) == id(l1)) # False

x = 100 or 200
print(x) # 100

class A:
    def check(self):
        return ""demo""

    def display(self):
        print(self.check())


class B(A):
    def check(self):
        return (""derived"")


A().display() # demo
B().display() # derived

for i in range(1, 3):
    for j in range(i, i+1):
        if j >= 2:
            break
    else:
        print(i) # 1

def func(**args, a=1):
    print(1)

def func(*args, a =1):
    print(1)

def func(a=1, *args):
    print(1)

def func(a=1, **args):
    print(1) # 第一个错


class Spam(object):
    n_i = 0
    def __init__(self):
        Spam.n_i +=1

class Sub(Spam):
    n_i = 0

sub = Sub()
print(sub.n_i, Spam.n_i) # 0 1

'北京'.encode('utf8')
'北京'.decode()
'北京'.encode().decode()
'北京'.encode() # 第二个错

下列哪些结果是2
1 a = [1,2,3]
2 print(list(filter(lambda x: x % 2 == 0, a)))
3 print(list(filter(lambda x: 3 * (x + 1) / 3 % 3 == 0, a)))"		2,3
		
关于高阶函数filter的使用,下面代码的输出是什么:
nums = [1,2,3,4,5]
result = list(filter(lambda x:x%2 == 0,nums))
print(result) # [2,4]

哪些不能正常输出foo bar
1 print(""""""foo'bar"""""")
2 print(""foo'bar"")
3 print('foo\'bar')
4 print('foo'bar')"		4

以下代码的输出是
import re

sum = 0
pattern = 'back'
if re.match(pattern, 'backup.txt'):
    sum += 1
if re.match(pattern, 'text.back'):
    sum += 2
if re.search(pattern, 'backup.txt'):
    sum += 4
if re.search(pattern, 'text.back'):
    sum += 8

print(sum) # 13

以下代码的输出是:
sentence = 'we are humans'
matched = re.match(r'(.*) (.*) (.*)', sentence)
print(matched.group())  # we are humans
print(matched.groups())  # ('we', 'are', 'humans')"		

以下代码的输出是:
m = re.match('(\w\w\w)-(\d?)', 'abc-123')
print(m.group())  # abc-1
print(m.groups())  # ('abc', '1')
print(m.group(0))  # abc-1
print(m.group(1))  # abc
print(m.group(2))  # 1"		

line = ""Cats are smarter than dogs""
# .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符
matchObj = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)

if matchObj:
    print(""matchObj.group() : "", matchObj.group())
    print(""matchObj.group(1) : "", matchObj.group(1))
    print(""matchObj.group(2) : "", matchObj.group(2))
else:
    print(""No match!!"")
以上实例运行输出结果为：
matchObj.group() :  Cats are smarter than dogs
matchObj.groups() :  ('Cats', 'smarter')
matchObj.group(0) :  Cats are smarter than dogs
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter

以下代码的输出是:
def outter():
    va = 0
    vb = 0
def inner():
    nonlocal va
    vb = 1
    va = 1
inner()
print(va, vb)
outter() # 1 0

以下哪个会返回False(C)
# A
print((r""<>."").isascii())
# B
print((u""Chinese"").isascii())
# C
print((u""中文"").isascii())
# D
print((b'Chinese'.isascii()))"		C

哪些会异常------选C
A s1 = '{}'.format('中文')
B s1 = '{}'.format('English')
C s1 = b'' + '中文'
D s1 = '%s'%'English'"		C

选项里有个print(b""+ "xxx")的一个题，应该是不能运行的		

哪个返回结果正确(C)
# A
2.0 << 2 # 返回8
# B
1 + 2j<< 2 # 返回4+8j
# C
(2) << 2 # 返回8
# D
[2] << 2 #返回8"		C

以下代码的输出是
import functools

int_base2 = functools.partial(int, base=2)
int_base16 = functools.partial(int, base=16)
print(int_base2('1000000')) # 64
print(int_base16('1101'))   # 4353

以下代码的输出是
import asyncio

async def main():
    print('hello')
   await asyncio.sleep(1)
   print('world')
asyncio.run(main())
答案:
hello
world

set的用法，哪一种可以把set中的2删掉(AB)	
# A
set1 = {1,2,3,4,5}
set1.remove(2)
set1
# B
set1 = {1,2,3,4,5}
set1.discard(2)
set1
# C
set1 = {1,2,3,4,5}
set1.pop()
set1
# D
set1 = {1,2,3,4,5}
del set1[2]"	AB

setPriority
原题目记不太清，大概是题目要想提高python运行的优先级该怎么使用setPriority。		选-20

import threading,time
mutex_1 = threading.Lock()
mutex_2 = threading.Lock()
def test1():
    print("in test1 lock1")
    mutex_1.acquire()
    time.sleep(3)
    mutex_2.acquire(timeout = 1)
    print("in test1 lock2")
    mutex_1.release()
def test2():
    print("in test2 lock2")
    mutex_2.acquire()
    time.sleep(3)
    mutex_1.acquire()
    print("in test2 lock1")
    mutex_1.release()
    mutex_2.release()
t1 = threading.Thread(target = test1)
t2 = threading.Thread(target = test2)
t1.start()
time.sleep(1)
t2.start()
t1.join()
t2.join()	
答案:
in test1 lock1
in test2 lock2
in test1 lock2
in test2 lock1

importlib.import_module
一道多选题，包的结构是：
a/a.py 
def func():
    pass
main.py
问在main.py里怎样导入a可以使 a.func() 正常运行。这题题目也附了
importlib.import_module()的官方文档。
# A.
from a import a
# B
import importlib.util
importlib.import_module("A.a"")
# C
import importlib.util
a = importlib.import_module("A.a"")
# D
import importlib.util
a = importlib.import_module("A"")"	AC

以下代码的输出是
class A:
    x = ""Hello""
    def __init__(self):
        self.x = ""Hello""
    @classmethod
    def say_bye(cls):
        cls.x = ""Bye""
a = A()
b = A()
a.say_bye()
print(a.x)
print(b.x)
答案:
Hello
Hello

以下代码的输出是:
class A:
    x = "Hello"
    def __init__(self):
        pass
    @classmethod
    def say_bye(cls):
        cls.x = ""Bye""
a = A()
b = A()
a.say_bye()
print(a.x) # Bye
print(b.x) # Bye

以下代码的输出是
class Foo: 
    name = 'Foo' 
    def __init__ (self,name): 
        self.name = name 
 
    @classmethod 
    def func(cls): 
        print(cls.name) 
 
class Bar(Foo): 
    name = 'Bar' 
 
bar = Bar ('bar') 
bar.func()"	
A. Foo
B. Bar
C. bar"	B


type(type({1,2,3}))		type

以下代码的输出是
unittest. TextTestRunner：
A. 可以通过run()来运行unit.TestSuite
B. 必须与unittest.Testsuite配合使用
C. 可以独立添加，无需unittest的类配合
D. 初始化的时候，可以让verbosity = 4"		A（多选的时候加个C）
"package对module的分层管理
选安全规范里的正例，每层有个 __init__ 的那个：
example_sdk
├───__init__.py # 定义外部可访问的子包和模块（module）清单
├───model # 所有数据模型的定义放在model包内
│ ├───__init__.py
│ ├───alarm.py
│ └───event.py
├───api # 所有访问层的方法放在api包内
├───__init__.py
│ └───client.py"		
"pdb的用法，想查看c的值该如何操作
原题代码不记得了，大概是定义了一个函数，之后外部调用了这个函数，想查看函数中一个
变量的值，选项是应该在第几行打断点，然后需要怎么s怎么p"	在第5行设置断点，执行到第5行时，再执行s, 然后执行p c	
测试(a||b) & (c||d)的需要多少个用例，不太确定		
"问 AA.__init__ 调用了几次，选两次
class AA(): 
    def __init__(self): 
        print("
AA"") 
 
class BB(): 
    def __init__(self): 
        AA.__init__(self); 
 
class CC(AA): 
    def __init__(self): 
        AA.__init__(self); 
 
class DD(BB, CC): 
    def __init__(self): 
        BB.__init__(self); 
        CC.__init__(self); 
 
if __name__ == ""__main__"": 
    d = DD()"		2次
如果读的文件比内存大怎么办，选项里三个都是直接read, 只有一个是设置了buffer，我选 了设置buffer的这个		
"import time
def task1():
while True:
print(""1-before"")
yield
print(""1-after"")
time.sleep(0.5)
def task2():
while True:
print(""2-before"")
yield
print(""2-after"")
time.sleep(0.5)
t1 = task1()
t2 = task2()
for _ in range(0, 2):
next(t1)
next(t2)"		"1-before
2-before
1-after
1-before
2-after
2-before"
"序列化的规范，题目还挺长，忘记是选正确的单选题还是错误的多选题了，反正只有用
json 是正确的，用 pickle, _pickle, shelve, yaml, jsonpickle 都是错的 (安全规
范3.13)"		
print('6' * 3)		666
"class Foo(object):
    pass

class Bar(Foo):
    pass
print(type(Foo()) == Foo)   # True
print(type(Bar()) == Foo)   # False
print(isinstance(Foo(), Foo)) # True
print(isinstance(Bar(), Foo)) # True"		
"class Base:
    pass

class Derive(Base):
    pass

a = Base()
b = Derive()

print(type(b) == Base) # False
print(isinstance(b, Derive)) # True"		"False
True"
"type的type是type 
type(123)是<class 'int'>
type(type(123))是<class 'type'>，type是一种特殊的类：元类，用来实例化产生类的类
print(type(type(type(123)))) #<class 'type'>"		

A = [1,2,3,4,5]
print(a[3:8]==a[3:5])"		TRUE
"class A(object):
    pass

class B(A):
    pass

b = B()

print(isinstance(b,A))  # True
print(isinstance(b,object))  # True
print(type(B)==type(A))  # True"		
"def handle(x): 
    i = 3 
 
def foo(x): 
    def bar(): 
        return i 
 
    for i in x: 
        handle(x) 
    return bar() 
 
i = 3 
 
def foo_1(x): 
    def bar(): 
        return i 
 
    y = [i for i in x] 
    handle(y) 
    return bar() 
 
print(""%s, %s"" % (foo(['x', 'y']), foo_1(['x', 'y'])))"	
A. y, 3
B. 3, y
C. y, y
D. 3, 3"	A
下面代码打印math模块中的pi正确的有（多选）	
A.
from math import pi 
print(pi)
B.
import math 
print(math.pi)
C.
from math import pi 
print(math.pi)
D.
import pi 
print(pi)"	AB
"v = [1, 2, 3, 4] 
y = (x * x for x in v) 
print(next(y), next(y))"	
A. 抛出异常
B. 1 1
C. 1 2
D. 1 4"	D
迭代器和迭代对象，如下说法正确的是（多选）	
A. 迭代器一定是可迭代的对象，但可迭代对象不一定是迭代器。
B. 可迭代对象一定是迭代器，但迭代器不一定是可迭代对象。
C. 实现了_iter_方法的对象是可迭代对象
D. 迭代器一定实现了_next_方法"	ACD
哪些可以作为字典的key? 不变的字符串或者元组均可，list和dict以及set不行。		
"建议类的多个方法按照如下的顺序组织：
1. __new__ 静态方法
2. __init__ 方法
3. __post_init__ 方法
4. 其它魔法函数
5. @property 修饰的对象属性
6. @staticmethod 修饰的静态方法
7. @classmethod 修饰的类方法
8. 普通方法
9. 保护方法或私有方法"		
"有一个单选，选正确的描述AD是关于continue的比较容易排除，B和C比较难以判断，答案选B。
B是break只能用于循环体内。
C是goto可以用来跳出多重循环。"		
下列哪种记录日志的方式符合《华为Python语言编程规范》中“日志”章节的要求和建议	
A.
import logging 
error_mes = ""This is an error msg."" 
logging.error(""Here is an error:%s"" % error_mes)
B.
import logging 
error_mes = ""This is an error msg."" 
logging.error(f""Here is an error:{error_mes}"")
C.
import logging 
error_mes = ""This is an error msg."" 
logging.error(""Here is an error:{}"".format(error_mes))
D.
import logging 
error_mes = ""This is an error msg."" 
logging.error(""Here is an error:%s"", error_mes)"	D
使用unitest的什么方法能正确运行测试用例	
A. unitest.main()
B. unittest.run()
C. unitest.run_cases()
D. unitest.test()"	A
"已知有以下函数
def some_function(some_number, some_list): 
    some_number = 2 
    some_list.append(1)
用以下代码调用函数some_function，
some_number = 1 
some_list = [1, 2, 3] 
some_function(some_number, some_list) 
print(some_number, some_list)
执行结果打印为"	
A. 2 [1, 2, 3, 1]
B. 1 [1, 2, 3, 1]
C. 2 [1, 2, 3]
D. 1 [1, 2, 3]"	B
"def f(a, b=[])  
Ret = a
Return len(a.append(b)) "	问 f(1), f(2,[1,1]), f(3)的输出	选择[1,1,1]
"import copy 
def copy_test():
    a = {'x':[1,2,3,4],'u':[123,234]}
    b = a 
    d = copy.deepcopy(a)
    e = copy.copy(a)
    e['x'][0] = 3
    e['u'] [0]= 234
    print(id(a)  == id(e))
    print(a)

copy_test()"		"False
{'x': [3, 2, 3, 4], 'u': [234, 234]}"
"import copy
a = {"
A"": [1, 2, 3, 4], ""b"": 123}
b = copy.deepcopy(a)
e = copy.copy(a)
e["
A""][0] = 3
e[""b""] = ""234""
print(id(a) == id(e), end=' ')
print(a)"		False {'a': [3, 2, 3, 4], 'b': 123}
"x = 3
y = 2
 
def func(y):
    global x
    x **= x
    y **= y 
    return x + y


func(y) "		31
"class Vehicle():
    pass
class Truck(Vehicle):
    pass

print(isinstance(Truck(), Vehicle))
print(type(Vehicle()) == Vehicle)
print(isinstance(Vehicle(), Vehicle))
print(type(Truck()) == Vehicle)"		"True
True
True
False"
"#下列哪些无异常，且在执行时不会向上层抛出未捕获的异常？

# A：
try:
    raise AException
except (AException, BException):
    pass

# B：
try:
   raise AException
except AException, BException:
   pass

# C：
try:
   raise AException
except Exception:
   pass

# D：
try:
    raise AException
except [AException, BException]:
    pass"		A  C
"try:
    words = ['a','b']
    int(words[2])
except IndexError: # 填入代码
    print('catched')


# except ValueError, IndexError:
# except (ValueError, IndexError) as e:
# except [ValueError, IndexError] as e:
# except IndexError:"		
		12
		
	还考了这个，选这个反例	
		
"语文和数学得分的，答案是
XX： 语文：95
XX：数学：99"		
"代码运行成功 且 x = {'a','b','c'}
print(set(['a','b','c']))
print(set('a','b','c'))
print(set(('a','b','c')))
print(set('abc'))"	"可以通过set()来将序列和字典转换为集合。
使用set()将字典转换为集合时，只会包含字典中的键。"	ACD
"控制语句的规范
if语句中的表达式应清晰直接，并且建议不超过3个，可以根据具体逻辑决定。
反例：
if activity.is_active and activity.remaining > 10 and \
user.is_active and (user.sex == 'female' or user.level > 3): # 此处的逻辑非常多，阅读困难，修改容易出错
user.add_coins(1024)
正例：
is_activity_valid = activity.is_active and activity.remaining > 10
is_user_valid = user.is_active and (user.sex == 'female' or user.level > 3)

if is_activity_valid and is_user_valid: # 此处的逻辑应清晰直接，建议在同一抽象层次上，不要陷入细节
user.add_coins(1024)"		
		
"n = [1,2]
v = n 
v[0] = 3
print(n, v)"		[3, 2] [3, 2]
"t1 = (1,2)
t2 = t1*2
t3 = t1 + t2 
print(t3)"		(1, 2, 1, 2, 1, 2)
"def func():
    name = 'LiLei'
    print(name,end = ',')

print(name)"		"Traceback (most recent call last):
  File ""D:\codehub\solution\solution-test\testcase\dorado\cases\anti_ransomware\temp.py"", line 862, in <module>
    print(name)
NameError: name 'name' is not defined"
print(int('1'+'2')+3)		15
"class Foo():
    @property 
    def x(self):
        return 10
    def get_y(self):
        return self.__y
    def set_y(self, value):
        self.__y = min(value, 20)

    y = property(get_y, set_y)

my_foo_object = Foo()
my_foo_object.y = 30 
print(my_foo_object.y - my_foo_object.x)"		10
"class Foo:
    @classmethod
    def create_one(cls):
        return cls()
    
    @staticmethod
    def create_two():
        return Foo()

class Bar(Foo):
    pass

bar_one = Bar.create_one()
bar_two = Bar.create_two()

print(isinstance(bar_one,Bar))
print(isinstance(bar_two,Bar))
"		"True
False"
"def decorate(func):
    def wrapper():
        print('start')
        func()
        print('end')
        return 'test_result_none'  # 没有此行，print的话就返回None
    return wrapper 
@decorate
def show():
    return 'show'

print(show())
print('------------')
show()"		"
start
end
test_result_none
------------
start
end"
"def show1():
    print('show1_test')
print(show1())"		"show1_test
None"
"test.txt文件原内容为 huawei 经如下运行后内容为？
with open('test.txt', 'wt') as file:
    file.write('Hello')
    file.write('World')"	"2023-1-11题目更新
test.txt文件原内容为 huawei 经如下运行后内容为？
with open('test.txt', 'r') as file:
    file.write('Hello')
    file.write('World')
答案应该为：文件为空"	HelloWorld
"def fun():
    funs = []
    for i in range(4):
        funs.append(lambda x: x+i)
    return funs 
lams = fun()
result = [lams[i](i) for i in range(4)]
print(result)"		[3, 4, 5, 6]
"def func():
    for i in range(5):
        yield i
a = func()
b = func()
print(next(a))
print(next(b))
print(next(a))
print(next(b))"		"0
0
1
1"
"class Spam(object):
    m = 0
    def __init__(self):
        Spam.m += 1 

class Sub(Spam):
    m = 0
sub = Sub()
print(sub.m, Spam.m, Sub.m)"		0 1 0
"test.py文件中内容如下
""""""
__all__  = ['A']
class A:
    def __init__(self):
        self.name = 'a'
class B:
    def __init__(self):
        self.name = 'b'
""""""
#如下两份代码的输出情况分别是什么？

from test import A,B 
#或替换为 
#from test import *
a = A()
b = B()
print('{0},{1}'.format(a.name, b.name))"		a,b
"如下可能打印内容
import random 

class RandomPrint():
    def __iter__(self):
        return self 
    def __next__(self):
        if random.choice(['go','go','stop']) == 'stop':
            raise StopIteration
        return 1 

print(list(RandomPrint()))
#[],[1],[1,1]..."		随机的，可能是[],[1],[1,1]…
"x=['a','b'],如下哪些代码可以将x变为['a','b','c','d']
x = ['a','b']
print(x)"	"x.extend(['c','d'])
x.append(['c','d'])  # ['a', 'b', ['c', 'd']]
x += ['c','d']
x += 'cd'"	ACD
"哪些返回 [0,'foo']
arr = [1,2,[3.1,[4.1,0,'foo'],2],'bar']"	"print(arr[2][1][1:])
print(arr[2][-2][1:])
print(arr[2][1][1:2])
print(arr[-2][1][1:3])"	ABD
"好的开发者测试可以带来什么价值？
"	
A 给前端提高效率
B 直接提高产品售价  
C 减少后端遗留问题
D 降低维护成本"	ACD
"以下路径符合‘文件’章节要求的？
"	"#A path = os.getcwd() + '/myDirectory'
#B path = os.getcwd() + '/' + myDirectory'
#C path = os.getcwd() + os.sep + file_name 
#D path = os.path.join(os.getcwd(),'myDirectory')"	CD
哪些可以作为字典的key	"#A dict(foo=1,bar=2)
#B ['foo','bar']
C (3+2j)
D ('foo','bar')
E 'foo'
# F {1,2,3}
G 1,2,3  # 元组形式"	CDEG
"哪一项正确 
"	
A、1<<2>>2（结果1）
B、1>>2<<2（结果1）
C、False<<1（结果False）
D、True<<1（结果True）"	AB
"foo = 1

def test(bar):
    global foo

    def fun(barz):
        foo = barz
        return foo

    fun(bar)
    return foo

test(100)
print(foo)"		1
"哪个选项打印出0：
class A:
    pass

a = A()"	
A、a.__a__x
B、a._a__x
C、a._A__x
D、a.__x"	D
以下哪个可以输出s为三个’a’,’b’,’c’的集合set（多选）	
A．s = set ([’a’,’b’,’c’])
B. s = set(‘abc’)
C. s = {(’a’,’b’,’c’)}
D. s= {‘a’, ‘b’, ‘c’}
E. s = (‘a’, ‘b’, ‘c’)"	ABDE
"以下代码打印
x = (""1"",
     ""22"",
     ""333"")

y = (""1""
     ""22""
     ""333"")
z = '''1
22'''

print(x)
print(y)
print(z)
print(len(x), len(y), len(z))"		"('1', '22', '333')
122333
1
22
3 6 4"
"下面能够输出'ababab'的是：
"	
A、
a = ['a', 'b']
a.extend(a)
a.extend(a)
print(''.join(a))  #abababab
B、
a = ['a', 'b']
a.append(a)
a.append(a)
print(''.join(a))
C、
a = ['a', 'b']
print(''.join(a*3))
D、
a = ['a', 'b']
print(''.join(a)*3)"	CD
"lan = u'中文'
print(len(lan), hasattr(lan, ""encode""))"		2 True
"class B(Exception):
    pass

class C(B):
    pass

class D(B):
    pass

res = []
for cls in [B, C, D]:
    try:
        raise cls()
    except B:
        res.append('B')
    except C:
        res.append('C')
    except D:
        res.append('D')

print(''.join(res))"		BBB
"class Test:
    def foo(self, seq=[]):
        seq.sort()
        # 字符串排序"
A"" > ""N""
        seq.append(""End"")
        print(seq)

test_1 = Test()
test_1.foo()

test_2 = Test()
test_2.foo()

test_3 = Test()
test_3.foo([""Name"", "
Age""])

test_4 = Test()
test_4.foo()"		"# ['End']
# ['End', 'End']
# ['Age', 'Name', 'End']
# ['End', 'End', 'End']"
"def func(x):
    x = yield x
    x = yield x

m = func(3)
for x in m:
    print(x, end='')"		3None
"S = [3, 1, 4, 5]
A = sorted(S, reverse = True)
print(A)"		[5,4,3,1]
"答案不确定

If A+B > 100 THEN

       Print(large)

IFEND

If A > 100 THEN

       Print(large A)

IFEND"	"条件覆盖最少需要几个用例？判定覆盖呢？
A．1, 3
B. 1, 2
C. 2, 2
D. 2, 3"	
"字典dict = {'a': 1, 'b': 2, 'c':3}
print(dict{key.super(),for key, value in dict.items()} ，输出：A

A、dict{‘A’: 1, ‘B’: 2, ‘C’: 3}
B、dict{‘a’: 1, ‘b’: 2, ‘c’:3}"		
"TEST1 = [ ‘A’,  ‘B’,‘C’,  ‘D’]
TEST2 = (‘A’,  ‘B’,  ‘C’,‘D’)
符合华为节省内存空间要求的是（具体记不清，列表和元组）：B
A． TEST1
B． TEST2
C． TEST1 和 TEST2
D． 都不符合"		
print('a' if 'b' else 'c') 		a
print([i for i in range(0,5)])		[0, 1, 2, 3, 4]
"class Demo:
    def __check(self):
        return ""demo check""

    def display(self):
        print(self.__check())


class Demo1(Demo):
    def __check(self):
        return ""deserv demo check""


Demo().display()  # demo check
Demo1().display()  # demo check"		
下面哪些操作可以顺利让表 x = [4, 1, 0, 3, 5]变 x = [4, 1, 3, 5]（多选）	
A. x[2] = []
B. del x[2]
C. x.remove(0)
D. x[2:3] = []"	BCD

A = [0, 1, 2 ,3 ] 
for a[-1] in a: 
    print( a[-1] )"	
A. 代码出错
B. 0, 1, 2, 3
C. 0, 1, 2, 2
D. xxx"	C
现有列表result = [2, 3, ['a', 'b', 'c'], 1]，python3解释器执行result[2].extend('de')后result的值是	
A.    [2, 3, ['a', 'b', 'c'], 1, 'de']
B.     [2, 3, ['a', 'b', 'c'], 1, 'd', 'e']
C.     [2, 3, ['a', 'b', 'c', 'd', 'e'], 1]
D.     [2, 3, ['a', 'b', 'c', 'de'], 1]"	C
"def remove_value_bigger_than_100(data):
    index = 0
    for unit in data:
        if unit > 100:
            del data[index]
        index += 1
    return data


x = [1, 212, 12, 123, 124]
print(remove_value_bigger_than_100(x))"	
A. 代码报错 IndexError: list index out of range
B. [1, 12]
C. [1, 12, 123]
D. [1, 12, 124]
E. [1, 212, 12, 123, 124]"	D

A = ('string',) 
for x in range(2): 
    a = (a,) 
    print(a)"	
A. 报错
B. (('string',),)
((('string',),),)
C. ('string',)
('string',)"	B
以下多行代码，可以执行的是（多选）	
A.
res = '1' + '2' + '3' 
    + '4' + '5' + '6' 
    + '7' + '8' + '9'
B.
res = ('1' + '2' + '3' 
       + '4' + '5' + '6' 
       + '7' + '8' + '9')
C.
res = '1' + '2' + '3' \ 
      + '4' + '5' + '6' \ 
      + '7' + '8' + '9'
D.
res = '1' + '2' + '3' \ 
      + '4' + '5' + '6' \ 
      + '7' + '8' + '9' \ 
 
其他代码块
"	BCD
以下能输出001的是（多选）	
A. print( ""{0:03d}"".format(1) )
B. print( ""{0:03}"".format(1) )
C. print( ""{0:3}"".format(1) )
D. print( ""{0:30d}"".format(1) )"	AB
以下哪个表达式的值为True	
A. 7 // 3.2 * 2 > 2
B. 7 // 3.2 ** 2 > 2
C. 3 or 2 & 5 ==1
D. 3 and 2 & 5 > 0"	A
"name = ""huawei"" 
for i,s in enumerate(name): 
    if s == ""w"": 
        print(i,'A') 
        break 
    if s == ""u"": 
        print(i,'B') 
else: 
    print(i,'X')"		"1 B
3 A"
"def make_fun(func): 
    def inner(): 
        print('make_fun().inner()') 
        func() 
 
    return inner() 
 
def function1(): 
    print('function1()') 
 
make_fun(function1)"	
A.
make_fun().inner() 
function1()
B.
make_fun().inner()
C.
function1() 
make_fun().inner()
D.
function1()"	A
"def func(a, *b): 
    for item in b: 
        a += item 
    return a 
m=0 
print(func(m,1,1))"	
A. 0
B. 1
C. 2"	C
以下哪些代码可以正确输出foobar		ABC
"class AException(Exception): 
    def __init__(self): 
        Exception.__init__(self, "
AException"") 
 
class BException(AException): 
    def __init__(self): 
        Exception.__init__(self, ""BException"") 
 
try: 
    try: 
        raise BException 
    except AException: 
        raise 
except Exception as exc: 
    print(""catch exception: %s"" % exc)
"		catch exception: BException
"def test(ver): 
    try: 
        if ver.lower() == ""true"": 
            return ""High"" 
    except Exception: 
        pass 
    else: 
        return ""M"" 
    finally: 
        return ""I"" 
print(test(True))"		I
"def divide(denominator, numberator): 
    try: 
        return denominator / numberator 
    except: 
        return '0' 
    finally: 
        return '-1' 
 
print(divide(denominator=2, numberator=1), divide(denominator=2, numberator=0))"	
A. 2 0
B. 2 -1
C. -1 0
D. -1 -1"	D
"以下代码打印的最大数字是
try: 
    print(1) 
    assert 2 + 2 == 5 
except AssertionError: 
    print(3) 
except: 
    print(4)"	
A. 3
B. 4
C. 5
D. 1"	A
"如下包及模块，运行test.py，输出结果是
# test.py 
from tests import * 
test2() 
 

# tests/__init__.py 
__all__ = ['test2'] 
 
from .test2 import test2 
 
def test2(): 
    print('hello python')
# tests/test2.py 
def test2(): 
    print('hello world')"	
A. hello world
B. hello python
C. ''"	B
		BD
以下关于模块说法正确的是（多选）	
A. 运行时会从指定的目录搜索导入的模块，如果没有，会报错异常
B. 模块文件的扩展名不一定是.py
C. 任何一个普通的xx.py文件可以作为模块导入
D. 一个xx.py就是一个模块"	ABC
"假设‘temp.txt’文件保存内容helloworld，则下面代码输出
with open('temp.txt', 'rb') as fr: 
    print(fr.read(5)) 
    print(fr.read())"	
A.
b'hello' 
b'world'
B.
hello 
world
C.
helloworld
D.
hello 
w"	A
Python打开文件的模式，正确的是（多选）	
A. 只读r
B. 追加写 a
C. 创建写 n
D. 覆盖写w"	ABD
"l = [1, 3, 5] 
li = iter(l) 
print(3 in li) 
print(3 in li)"	
A. True, True
B. True, False
C. False, False
D. False, True"	B
"def deco_a(func): 
    def wrapper(*args, **kwargs): 
        print('deco_a') 
        func(*args, **kwargs) 
 
    return wrapper 
 
def deco_b(func): 
    def wrapper(*args, **kwargs): 
        func(*args, **kwargs) 
        print('deco_b') 
 
    return wrapper 
 
@deco_a 
@deco_b 
def test(): 
    print('function running') 
 
test()
"		"deco_a 
function running 
deco_b"
		
"在以下Python代码中，哪个函数可以被当做装饰器使用
def test1(x): 
    def test11(): 
        print('Decorated') 
        x() 
    return test11 
 
 
def test2(): 
    print('Originary') 
 
p = test1(test2) 
p()"	
A. p
B. test1
C. test11
D. test2"	B
"选项中对以下代码，说法正确的有（多选）
class Person(object): 
    def __init__(self, birth_year): 
        self._birth_year = birth_year 
 
    @property 
    def birth_year(self): 
        return self._birth_year 
 
    @birth_year.setter 
    def birth_year(self, value): 
        self._birth_year = value 
 
    @property 
    def age(self): 
        return 2021 - self._birth_year 
 
person = Person(1990) 
person.birth_year = 2000"	
A. person.age 返回值为21
B.
person.age = 11 
print(person.birth_year)
的打印结果为2010
C. print(person.__dict__) 的打印结果是 {'_birth_year': 2000}
D. print(person.birth_year) 的结果为 2000"	ACD
"class Parrot: 
    def __init__(self): 
        self._voltage = 10000 
 
    @property 
    def voltage(self): 
        return self._voltage 
 
    @voltage.setter 
    def voltage(self, value): 
        if value < 0: 
            raise ValueError(""Invalid voltage value"") 
        self._voltage = value 
 
    @voltage.deleter 
    def voltage(self): 
        del self._voltage 
 
p = Parrot() 
del p.voltage 
p.voltage = -1 
print(p.voltage)"		ValueError: Invalid voltage value
我们日常针对面向对象类成员的getter、setter方法写法，在Python中被认为是更加'Pythonic'的优雅写法是：	
A. 类公有变量写法；
B. 生成器写法；
C. 迭代器写法；
D. @property写法"	D
下列有关装饰器的用法，错误的是	
A. property装饰器可以用来规范属性访问，常用来限制对属性的访问（getter）和设置（setter）
B. classmethod装饰器对应的函数不需要实例化，不需要self参数，但第一个参数需要时表示自身类的cls参数，可以用来调用类的属性，类的方法，实例化对象等；
C. staticmethod装饰器对应的函数不需要实例化，不需要self/cls参数，就跟使用普通函数一样
D. 多装饰器叠加在一个函数上，执行这个函数时，最内部（最靠近函数）的装饰器最先被调用"	D
"class ListMetaclass(type): 
    def __new__(cls, name, bases, attrs): 
        print(name) 
        print(bases) 
        attrs['add'] = lambda self, value: self.append(value) 
        return type.__new__(cls, name, bases, attrs) 
 
 
class DefinedList(list, metaclass=ListMetaclass): 
    pass 
 
 
definedList = DefinedList() 
definedList.add(1)"	
A.
ListMetaclass 
(<class 'list'>,)
B.
DefinedList 
(<class 'type'>,)
C.
DefinedList 
(<class 'list'>,)
D.
ListMetaclass 
(<class 'type'>,)"	C
"如果想要得到下面输出，则在“__#待填”填写下面哪些代码（多选）注意，题可能不对!!!
输出Call ... 20 Call ... 20
class Property: 
    def __init__(self, function, **kwargs): 
        self.function = function 
 
    def __get__(self, instance, owner): 
        __ #待填 
class Factory: 
    def __init__(self): 
        self._x = 10 
        self._y = 2 
    def product(self): 
        print(""Call ..."") 
        return self._x * self._y 
 
    product = Property(product) 
 
f = Factory() 
print(f.product) 
del f.product 
print(f.product)"	
A.
return self.function(instance)
B.
result = self.function(instance) 
instance.__dict__[self.function.__name__] = result 
return result
C.
result = self.function(instance) 
instance.__setattr__(self.function.__name__, result) 
return result
D.
result = self.function(instance) 
setattr(instance, self.function.__name__, result) 
return result
E.
result = self.function(instance) 
type(instance).__dict__[self.function.__name__] = result 
return result
"	BCD
"class Foo: 
    def __init__(self, name): 
        self._name = name 
    def __str__(self): 
        return self._name 
    def __eq__(self, other): 
        return self is other 
 
class Bar(Foo): 
    def __eq__(self, other): 
        return str(self) == str(other) 
 
foo = Foo('Hello') 
bar = Bar('Hello') 
print(foo == bar) 
print(bar == foo)"	
A.
True
True
B.
True
False
C.
False
True
D.
False
False"	A
"class Person: 
    __slots__ = ('name', 'age') 
person = Person() 
person.name = 'John' 
person.name = 'Kate' 
person.nationality = 'CN' 
person.nationality = 'UK' 
print(f""{person.name} is from {person.nationality}"")"	
A. John is from UK
B. Kate is from UK
C. 代码执行会抛出AttributeError
D. John is from CN
E. Kate is from CN"	C
"已有以下代码（多选）
class A: 
    x = 0 
    def func(self): 
        print(self.x) 
a = A() 
a.x = 0"	"则下列哪些语句可以打印出0
A.  a.func()
B.  a.func(a)
C.  A.func(a)
D.  A.func(A)"	ACD
"class Foo: 
    count = 0 
 
    def __init__(self): 
        self.count = 0 
 
    def incr_one(self): 
        self.count += 1 
 
    @staticmethod 
    def incr_two(): 
        Foo.count += 1 
 
    @classmethod 
    def incr_three(cls): 
        cls.count += 1 
 
class Bar(Foo): 
    pass 
 
foo = Foo() 
bar = Bar() 
foo.incr_one() 
bar.incr_one() 
foo.incr_two() 
bar.incr_three() 
Foo.incr_two() 
Bar.incr_three() 
Foo.incr_three()
"	
A. Foo.count 的值为1
B. Bar.count 的值为3
C. foo.count 的值为2
D. bar.count 的值为1
E. Foo.count 的值和Bar.count 的值相等"	BDE
"class Spam(object): 
    num_instance = 0 
 
    @staticmethod 
    def count(): 
        Spam.num_instance += 1 
 
    def __init__(self): 
        self.count() 
 
class Sub(Spam): 
    num_instance = 0 
 
class Other(Spam): 
    num_instance = 0 
 
x = Spam() 
y1, y2 = Sub(), Sub() 
z1, z2, z3 = Other(), Other(), Other() 
print(x.num_instance, y1.num_instance, z1.num_instance) 
print(Spam.num_instance, Sub.num_instance, Other.num_instance)"	
A.
1 1 1
0 0 0
B.
6 0 0
6 0 0
C.
1 2 3
1 2 3
D.
6 0 0
1 2 3"	B
如下代码，描述正确的是	
A. 警告: 类方法(classmethod)是类所拥有的方法, 传入的参数应该是cls,而不是self""
B. 错误: Python没有new关键字, 如需修改new, 如单例模式, 可以重写(override)__new__"",
C. @property,表示属性, 不是方法, 则不需要加括号(), 直接调用object.man即可"",
D. 如果想使用基类的成员, 则需要初始化基类,如dummyclass.__init__(self)"",
E. 类名尽量使用大驼峰"",
"	ABCDE
"class A: 
    def __eq__(self, other): 
        return True 
a = A() 
print(a == None) 
print(a is None)"	
A.
False
False
B.
True
False
C.
True
True
D.
Flase
True"	B
"class MyClass(): 
    pass 
 
myclass = MyClass() 
print(myclass) 
print(type(myclass)) 
yourclass = type('YourClass', (),{}) 
print(yourclass) 
print(type(yourclass))
"		"<__main__.MyClass object at 0x000001E2FCF87B50>
<class '__main__.MyClass'>
<class '__main__.YourClass'>
<class 'type'>
"
"跟下面代码同样功能的是
import random 
random.seed('2021')"	
A. random.seed(2021, version=2)
B. random.seed('2021', version=1)
C. random.seed(b'2021', version=1)
D. random.seed(bytearray(b'2021'), version=2)"	D
不属于 time.structtime 时间元祖属性的是	
A. tm_year
B. tm_mon
C. tm_yday
D. tm_microsec"	D
"以下代码的输出是
from datetime import date 
print(date(2002, 12, 4))"	
A. 04-12-2002
B. Dec 04 2002
C. 2002-12-04
D. 2002/12/04"	C
"输出以下字符串中的所有数字，以下表达式正确的是（多选）
import re
x = 'abaax12323ddd'"	
A.
t = re.match(r""[a-zA-Z]+(\d+?)[a-zA-Z]+"", x).group(1) 
print(t)
B.
t = re.match(r""[a-zA-Z]+(\d+)[a-zA-Z]+"", x).group(1) 
print(t)
C.
t = re.match(r""[a-zA-Z]+(\d*)[a-zA-Z]+"", x).group(1) 
print(t)
D.
t = re.match(r""[a-zA-Z]+(\d+?)"", x).group(1) 
print(t)"	ABC
如下代码，哪些能输出123（多选）	
A.
import re 
content = ""Why you think 123 is a lucky number?"" 
result = re.match('Why you think.*?(\d+).*', content) 
if result: 
    print(result.group(1))
B.
import re 
content = ""Why you think 123 is a lucky number?"" 
result = re.match('^Why you think.*?(\d+).*', content) 
if result: 
    print(result.group(1))
C.
import re 
content = ""I think 123 is a lucky number."" 
result = re.search('^I think.*?(\d+).*$', content) 
if result: 
    print(result.group(1))
D.
import re 
content = """"""Today is a good day. 
I think 123 is a lucky number."""""" 
result = re.findall('.*?(\d+).*', content) 
if result: 
    print(result.group(1))
"	ABC
关于venv正确的有（多选）	
A. 可以用来搭建python虚拟环境
B. 是与CPython不同的另一种解释器
C. 是官方的标准库
D. 仅能在linux使用"	AC
"import asyncio 
 
async def say_hello(delay, msg): 
    await asyncio.sleep(delay) 
    print(msg) 
 
async def fun14(): 
    task1 = asyncio.create_task(say_hello(1, ""hello1"")) 
    task2 = asyncio.create_task(say_hello(2, ""world1""))  #注，之前这里是1，实际真题应该是2，不过不影响结果 
 
    await say_hello(1, ""hello2"") 
    await say_hello(2, ""world2"")   #注，之前这里是1，实际真题应该是2，不过不影响结果 
    await task1 
    await task2 
 
asyncio.run(fun14())"		"hello2 
hello1 
world1 
world2
"
logging 多线程是否安全	
A. 是
B. 否"	A
		3
以下关于字符串引号使用符合规范的是（多选）	
A.
std_out = \ 
    """"""This is much nicer. 
    Do it this way.""""""
B.
print(""This is much nicer.\n"" 
      ""Do it this way.\n"")
C.
print(""""""This is pretty ugly. 
Don't do this. 
"""""")
D.
std_out = ""This is much nicer. Do it this way."""	BD
下述哪些选项不符合《华为Python语言编程规范》中“运算符与表达式”这一章节中的要求和建议（多选）		ABC
下述哪个选项符合《华为Python语言编程规范》中“控制语句”这一章节中的要求和建议		
关于控制语句，下述哪些选项不符合《华为Python语言编程规范》要求和建议（多选）		
以下哪些是不符合控制语句章节规范的（多选）	
A.
for i in range(len(my_list)): 
    do_something(my_list[i])
B.
for x in my_list: 
    do_something(x)
C.
for i, x in enumerate(my_list): 
    print(i, x)
D.
for i in range(32): 
    do_something()"	AD
下述那个选项的代码符合《华为Python语言编程规范》中“变量作用域”章节的要求和建议		
下列变量的使用，符合变量作用域一章的规范的是	
A.
def fun(): 
    type = 'str' 
    return type
B.
_global = 1 
def test(): 
    local_number = 2 
    if local_number == _global: 
        raise MyException
C.
_global = 1 
def test(): 
    _global = 2"	B
"有如下模块moduleA，以下在moduleB中引入模块符合规范的是
# moduleA.py 
__all__ = ['ClassA'] 
 
class ClassA: 
    pass 
 
class ClassB: 
    pass
# moduleB.py"	
A.
from moduleA import * 
a = ClassA() 
b = ClassB()
B.
from moduleA import ClassA, ClassB 
a = ClassA() 
b = ClassB()
C.
import moduleA 
a = moduleA.ClassA() 
b = moduleA.ClassB()
D.
from moduleA import ClassA 
a = ClassA()"	D
linux环境中，为了能够 import 在 /my_path 路径下的包（package），以下做法不符合《华为Python语言编程规范》中“标准库”章节的要求和建议的有（多选）	
A. 运行代码前，在bash中执行 export PYTHONPATH=$PYTHONPATH: /my_path
B. 在代码中添加
sys.path.insert(0, './') 
sys.path.insert(0, './my_path')
C. 在代码中添加 sys.path = ['/my_path']
D. 在代码中添加 sys.path.insert(0, './my_path')"	BCD
data是来自外部未经校验的数据，下列反序列化的操作中，符合序列化的是	
A. pickle.loads(data)
B. yaml.load(data)
C. json.loads(data)
D. jsonpickle.decode(data)"	C
如下选项不符合《华为Python语言编程规范》中“外部数据校验”章节的要求和建议的是	
A.
os.system('sudo rm -f %s' % tmp_file)
B.
shutil.rmtree('python/filename')
C.
tmp_dir = 'abc' 
os.rmdir(""/tmp/log/%s"" % tmp_dir)
D.
tmp_dir = 'abc.tmp' 
os.rmdir(""/tmp/log/%s"" % tmp_dir)"	A
以下选项符合《华为Python语言编程规范》 中“外部数据校验”章节的要求和建议的是		
uniTtest命名规则正确的是	
A. abc_test
B. test_abc
C. abctest
D. abc"	B
1.3.3 {py27,py36}-django{15,16} 的 2 组花括号内各有 2 个值，它们实际可以组合环境		py27-django15、py27-django16、py36-django15、py36-django16
只用边界分析方法，如下哪些可以作为测试数据（多选）	
A. 最大值和最小值
B. 最小值-1
C. 最大值+1
D. 默认值"	ABC
		C
已知漏洞修补结果的验证已融入公司的测试流程，测试工程师在不同的活动阶段需要输出不同交付件不包括	
A. 补丁测试报告
B. 产品安全测试方案
C. 产品功能测试报告
D. 产品安全测试报告"	C
1.3.14 unittest.mock的patch函数下列错误的是	
A. patch可以作为装饰器
B. patch作为装饰器不会影响测试用例入参
C. patch可以与with使用
D. patch可限制mock的范围在函数或类"	B
"如下uniTtest的输出结果是
import unittest 
class MyTestCase(unittest.TestCase): 
    def setUp(self) -> None: 
        pass 
 
    def tearDown(self) -> None: 
        pass 
 
    def test_2(self): 
        print(""2"") 
 
    def test_1(self): 
        print(""1"") 
 
    def test_4(self): 
        print(""4"") 
 
    def test_3(self): 
        print(""3"") 
 
    def test_5(self): 
        print(""5"") 
if __name__ == ""__main__"": 
    unittest.main()
"		1 2 3 4 5
"import unittest 
 
class testcase(unittest.TestCase): 
    def test_something1(self): 
        print(1) 
 
    def test_something2(self): 
        print(2) 
 
    def setUp(self): 
        print(3) 
 
    def some_test(self): 
        print(4) 
 
    def tearDown(self): 
        print(5) 
 
unittest.main()"		"3
1
5
3
2
5
"
"以下内容，采用路径全覆盖的方法，需要多少测试用例  
if(a<b){ 
    if(c == 0){ 
        xxx 
    }else{ 
        xxx 
    } 
}else{ 
    xxx 
}"		3
pdb调试myscript.py的命令行	
A. python3 –m myscript.py
B. python3 –d myscript.py
C. python3 –pdb myscript.py
D. python3 –m pdb myscript.py"	D
以下可用于Python性能分析的是	
A. timeit
B. cProfile
C. line_Profiler
D. memory_Profiler"	ABCD
"list a操作时间复杂度O(n)的是
"	
A. a[0]==n,
B. n not in a
C. a.count(n) 
D. a.index(n)"	BC
双端队列deque(1),extend([2,3]),leftextend([4,5]), 结果是[5,4,1,2,3]		
"from collections import Iterable,Iterator

class IterObj:
    def __iter__(self):
        return self


it = IterObj()

print(isinstance(it,Iterable))
print(isinstance(it,Iterator))"	
A.True,False
B.True,True
C.False,True
D.False,False"	A
"from collections import deque

dq = deque([1])
dq.extend([2,3])
dq.extendleft([4,5])
print(list(dq))"	
A.[[5,4],1,[2,3]]
B.[4,5,1,2,3]
C.[[4,5],1,[2,3]]
D.[5, 4, 1, 2, 3]
"	D
"y = 1
f = lambda x: x + y + 1
y = 0
print(f(1)) # 2"		
"x,y,z = (1,2,3,4,5,6,7)[2::2]
print(y)"	
A.6
B.4
C.3
D.5"	D
"def deco(f):
    def inner():
        inner.co += 1
        f()
    inner.co = 0
    return inner

@deco
def func():
    pass


func()
func()
func()
print(func.co)  # 3"		
"dt = datetime.datetime(2022,2,22)
dt1 = datetime.timedelta(4)

print(dt+dt1)"	
A.2022-02-22 00:00:00
B.2026-02-22 00:00:00
C.2022-02-22 04:00:00
D.2022-02-26 00:00:00"	D
"from multiprocessing import Process, Pipe

def f(conn):
    conn.send('hello world')
    conn.send('hello world again')
    conn.close()

if __name__ == '__main__':
    parent_conn, child_conn = Pipe()
    p = Process(target=f, args=(child_conn,))
    print(parent_conn.recv())   # ""hello world""
"		
"class Foo:
    def __init__(self, val):
        self._val = val

    def __call__(self, b):
        return self._val * b
    def __add__(self, other):
        return Foo(self._val+int(other))
    def __int__(self):
        return self._val

foo = Foo(1)
bar = Foo(2)
print(foo(3))
foo = foo + bar
print(foo(1))"	
A.3,1
B.3,3
C.3,5
D 1,5"	B
如下哪些是int类型：	
A 0b1011
B 0xacd
C 12_00
D float(3)"	ABC

A = [""HELLO""]
print(""第一个值{0[0]}，第二个值{0[2]}"").format(a)"		第一个值H，第二个值L
有一道while中加了sleep(5)的，还有print(end)		"T-minus 3
T-minus 2
T-minus 1
end"
"listA = [1,2,3,4]
求 [i if x%2 == 0 else i*i for x in listA]的结果"		[1, 2, 9, 4]
有Pip, Process，parent, children的一个输出题	"hello world'
['hello world', 'hello world again']
'hello world again'
产生异常"	hello world'-恒瑞答案
"listA = [1,2,3,4]
filter(lambda i: i%2 for i in listA)"	"[1, 3]
None
[0, 1, 2, 3]
[0, 2]"	[1, 3]

A=[1,2,3,4,5]
b=a
c = a.copy()
如果id(a) = 4404896968, 问 id(b)和id(c)可能为什么？"	" `4404896968 4404896904`
 `4404896968 4404896968`
`4404896904 4404896968`
`4404896904 4404896904`"	4404896968 4404896904
如下说写法正确的是	"判断tuple内容是否为空： if my_tuple is ()
比较两个list内容是否相同：if list1 is list2
比较两个tuple的内容是否相同：if tuple1 == tuple
比较两个时间是否相等：if time1 is time2"	if tuple1 == tuple
如下条件语句符合编码规范的是？	
A、
def sample_sort_list(sample_inst):
    if not isinstance(sample_inst, list):
        pass
    dosomthing()
fake_list = (6, 8)
sample_sort_list(fake_list)
B、
if type(user) == User:
    print(user.name)
C、
def sample_sort_list(sample_inst):
    if sample_inst is []:
        pass
    dosomthing()
fake_list = (2, 3, 1, 4)
sample_sort_list(fake_list)
D、
if isinstance(var[3], int) or isinstance(var[3], float):
    pass"	D
"extend是右合并，leftextend是左合并
a = [1]
b = [2,3]
c = [4,5]
a.extend(b)
b.leftextend(c)  
问a是多少"	"[5, 4, 1, 2, 3]
[4, 5, 1, 2, 3]
[[5, 4], 1, [2, 3]]
[[4, 5], 1, [2, 3]]"	A
如下哪些结果输出是-9.54	
A、
print(Decimal('-9.545').quantize(Decimal('0.01'), rounding=ROUND_HALF_EVEN))
B、
print(Decimal('-9.545').quantize(Decimal('0.01'), rounding=ROUND_CEILING))
C、
print(Decimal('-9.545').quantize(Decimal('0.01'), rounding=ROUND_UP))
D、
print(Decimal('-9.545').quantize(Decimal('0.01'), rounding=ROUND_FLOOR))"	AB
下列代码能输出[0,1,2,3,4]的是	
A、
print([0, 1, 2, 3, 4])
B、
print(range(0, 5))
C、
x = []
for i in range(5):
    x.append(i)
print(x)
D、
x = []
for i in range(0, 4):
    x.append(i)
print(x)"	AC
设置断点后，能停留在print语句前面的是哪些代码？	
A、
def say():
    print(""hello, world"")
breakpoint()
if __name__ == ""__main__"":
    say()
B、
import pdb
pdb.set_trace()
def say():
    print(""hello, world"")
if __name__ == ""__main__"":
    say()
C、
import pdb
def say():
    pdb.set_trace()
    print(""hello, world"")
if __name__ == ""__main__"":
    say()
D、
def say():
    print(""hello, world"")
    breakpoint()
if __name__ == ""__main__"":
    say()"	ABC
如下输出等于1的代码是	
A
y = 1
ls = (y for y in range(10))
print(y)

B
w = 1
ls = []
for w in range(0):
    ls.append(w)
print(w)

C
w = 1
ls = []
for w in range(10):
    ls.append(w)
print(w)

D
x = 1
ls = [x for x in range(10)]
print(x)"	ABD
编程规范题，如下哪些是在解压文件前必须要做的安全检查？	
A
    total_size = sum(info.file_size for info in src_file.infolist())
    if total_size >= MAX_SIZE:    # MAX_SIZE是允许的文件大小的上限
        raise IOError(f'zipfile({zip_file}) size({total_size}) exceed max limit')
B
    file_count = len(src_file.infolist())
    if file_count >= MAX_FILE_CNT:   # MAX_FILE_CNT是允许的文件数量的上限
        raise IOError(f'zipfile({zip_file}) contains {file_count} files exceed max file count')
C
    dest_dir_partition = dest_dir
    total_size = sum(info.file_size for info in src_file.infolist())
    if total_size >= psutil.disk_usage(dest_dir_partition).free:
        raise IOError(f'zipfile({zip_file}) size({total_size}) exceed remain target disk space')
D
    if oct(os.stat(zip_file).st_mode)[-3:] > '640':
        raise IOError(f'zipfile({zip_file}) permission is not right')"	ABC
"package结构如下
package
subpackage1
    -moduleX
    -moduleY
subpackage2
    -moduleZ
    -moduleA
在moduleY文件中导入模块正确的是？"	
A
from ..subpackage2.moduleZ import xxx
B
from .moduleY import xxx
C
from . import moduleY
D
from ..moduleA import xxx"	ABC？
测试代码中不符合断言规范的是：	
A、
import unittest
class TestCaseDemo(unittest.TestCase):
    def test_object_is_in_collection (self):
        x = set([1,2,3,4])
        y = set([1,3,5])
        self.assertNotIn(5, x - y)
        self.asserIn(5, y - x)
B、
import unittest
class TestCaseDemo(unittest.TestCase):
    def test_object_is_instance_or_not_is_instance (self):
        x = [1, 2, 3, 4]
        self.assertIsInstance(x.sort(), list)
        self.assertIsNotInstance(sorted(x), list)
C、
import unittest
class TestCaseDemo(unittest.TestCase):
    def test_bool_values(self):
        true, false = True, False
        self.assertEqual(true, True)
        self.assertEqual(false, False)
D、
import unittest
class TestCaseDemo(unittest.TestCase):
    def test_object_is_none_and_not_none(self):
        x, y = None, ''
        self.assertIsNone(x)
        self.assertIsNotNone(y)"	C
被装饰器装饰的函数反复执行3次，装饰器中变量加1，求输出的结果		3
