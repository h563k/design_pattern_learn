1、（单选）良好的测试防护网是重构成功的重要前提，其中单元测试是构建测试防护网常用的
手段。下述哪种做法是重构过程中较好的单元测试行为 （C）

A.
被测对象依赖了外部接口，为了便于观察调用行为，对外部接口打桩，并通过打印到屏幕进行人工观察
B.
为了减少重复，将多个前置条件相同（如输入相同）的功能点在一个测试用例里进行合并测试
C.
重构过程中，为了提升测试效率，优先设计与修改代码有关的测试用例
D.
重构过程中，一旦修改代码，都需要对所有测试用例进行全量覆盖测试

2、（单选）以下哪项是推荐使用的加密算法 （C）
A.
自行定义的通过变形/字符移位/替换等方式执行的数据转换算法
B.
用编码的方式（如Base64编码）实现数据加密的目的的伪加密实现
C.
使用AES算法
D.
未公开的密码算法

3、（单选）对以下代码进行重构，方案最佳的是（B）

void CheckSecurity(const vector& people) { 
	static const string miscreantDon = "Don"; 
	static const string miscreantJohn = "John"; 
	string found = ""; 
	for (int i = 0; i < people.size(); i++) { 
		if (people[i].compare(miscreantDon) == 0) { 
			found = miscreantDon; 
		} else if (people[i].compare(miscreantJohn) == 0) { 
			found = miscreantJohn; 
		} 
	} 
	HandleMiscreant(found); 
}

A.
void CheckSecurity(const vector& people) { 
	static const string miscreantDon = "Don"; 
	static const string miscreantJohn = "John"; 
	string found = ""; 
	for (int i = 0; i < people.size(); i++) { 
		if (found.compare("") == 0) { 
			if (people[i].compare(miscreantDon) == 0) { 
				found = miscreantDon; 
			} else if (people[i].compare(miscreantJohn) == 0) { 
				found = miscreantJohn; 
 			} 
		} 
 	} 
 	HandleMiscreant(found); 
}

B.
string FoundMiscreant(const vector& people) { 
	static const vector miscreantNames = {"Don", "John"}; 
	for (int i = 0; i < people.size(); i++) { 
		for (int j = 0; j < miscreantNames.size(); j++) { 
			if (people[i].compare(miscreantNames[j]) == 0) { 
				return miscreantNames[j]; 
			} 
		} 
	} 
	return ""; 
} 

void CheckSecurity(const vector& people) { 
	string found = FoundMiscreant(people); 
	HandleMiscreant(found); 
}

C.
void CheckSecurity(const vector& people) { 
	static const string miscreantDon = "Don"; 
	static const string miscreantJohn = "John"; 
	string found = ""; 
	for (int i = 0; i < people.size(); i++) { 
		if ((found.compare("") == 0) && (people[i].compare(miscreantDon) == 0)) { 
			found = miscreantDon; 
		} 
		if ((found.compare("") == 0) && (people[i].compare(miscreantJohn) == 0)) { 
			found = miscreantJohn; 
		} 
	} 
HandleMiscreant(found); 
}

D.
void CheckSecurity(const vector& people) { 
	static const vector miscreantNames = {"Don", "John"}; 
	for (int i = 0; i < people.size(); i++) { 
		for (int j = 0; j < miscreantNames.size(); j++) { 
			if (people[i].compare(miscreantNames[j]) == 0) { 
				HandleMiscreant(miscreantNames[j]); 
				return; 
			} 
		} 
	} 
}

4、（单选）无情重构又称童子军原则，指你打开一个代码，如果很难理解，就应该试着去重构它，你离开的时候代码应该比你来的时候更易懂。但是通常我们由于缺乏足够的知识，不能在无情重构中进行复杂的重构，常常以抽取函数为主，但不好的抽取并不能让代码更易理解，反而更复杂。那么今天，你打开了下列的代码，可能不清楚具体的业务背景，但请尝试用函数抽取的方式进行无情重构。你觉得哪部分代码被抽出去作为一个函数，并不能提升代码的可读性（请忽略不同编程语言的规范和语法差异）（C）

public class Businesssite {
	private Reading[] readings = new Reading [1000];
	private static final double START_RATE = 0.09;
	private static double END_RATE = 0.05;
	private static int END_AMOUNT = 1000;

	public void addReading (Reading nevReading) {
		readings [++lastReading) = nevReadino;
	}

	private int lastReading;

	public Dollars charge () {
		Dollars result;
		int usage = readings[lastReading].getAnount() - readings[lastReading - 1].getinount();
		if (usage = 0){
		return nev Dollars (0);
		}
		double t1 = START_RATE - ((END_RATE * END_ANOUIT) - START_RATE) / (END _AMOUNT -1)
		double t2 = ((END RATE * END_ANOUNT)-START_RATE) * Math. min (END_AMOUNT, usage) / 
		(END_AMOUNT - 1) ;
		double t3 = Math. max (usage - END_AMOUNT, 0) * END_RATE;
		result a new Dollars (tl + +2 + t3) ;
		result = result.plus (new Dollars (usage * 0.0175));

		Dollars basel = nev Dollars(result.min(new Dollars(50)). times(0.07))
		if (result.isGreaterThan(new Dollars(50))) {
		basel = new Dollars(basel.plus(result.min (new Dollars (75)).minus (
		nev Dollars(50)).times (0.06)
		));
		}
		if (result.isGreaterThan(new Dollars (75))){
		basel = new Dollars(basel.plus(result.minus(new Dollars(75)).times(0.05)));
		}
		result = result.plus(basel);
		return result;
	}
}
A.
第19～23行
B.
第15行
C.
第14～24行
D.
第26～34行

5、（单选）根据《身份和访问管理安全设计规范》，以下哪种场景不应该产生安全告警（D）
A.
连续登录认证失败达到系统设定的次数
B.
身份认证凭证即将过期或已过期
C.
敏感功能的开启，比如端口镜像
D.
业务模块加载失败

6、（单选）以下哪种访问控制模式适用于政府、军事等组织分层比较明确、限制比较严格的系统（C）
A.
访问控制列表模式
B.
身份联合模式
C.
多级安全模式
D.
自主访问控制模式

7、（单选）在类图中，哪种关系表达总体与局部的关系（D）
A.
依赖（Dependency）
B.
实现（Realization）
C.
泛化（Generalization）
D.
聚合（Aggregation）


8、（单选）架构师要求需求的分析和设计变更都要加上唯一标识，然后关联用例，体现了需求的（C）
A.
可注释
B.
可检视
C.
可追溯
D.
可验证

9、（单选）对于下列函数实现，从单一职责，功能一致性等方面考虑，定义或者实现不合理，需要重构的有（忽略不同编程语言格式规范和语法差异）（B）

A.
```cpp void SetScore(int value) { m_score = value; // m_score是成员变量 } ```
B.
```cpp // 根据节点名称获取节点对象指针 Node* GetNode(const string& name) { Node* node =
findInNodes(name); if (node == nullptr) { return (new Node(name)); } return node; } ```
C.
```cpp int GetScore() const { return m_score； // m_score是成员变量 } ```
D.
```cpp // 根据名称获取对应记录 Record* GetRecord(const string& name) { Item* item = findItem(name);
if (item != nullptr) { return item->record; } return nullptr； } ```



11、（单选）用于描述两个对象之间消息交互的UML图是 （B）
A.
部署图（Deployment Diagram）
B.
顺序图（Sequence Diagram）
C.
对象图（Object Diagram）
D.

状态图（State Diagram）

12、（单选）如下代码存在什么坏味道，请忽略不同编程语言的差异和规范差异（B）
java
public static class EventOneHandler implements Handler {
	private static final StringEVENT_TYPE = "EventOne";
	@Override
	public void handle()
{
LogUtil.log(EventUtils.getMessage(EVENT_TYPE, "start"));
	try {
 
handleEventOne();
LogUtil.log(EventUtils.getMessage(EVENT_TYPE, "success"));
	} catch(HandleException e) {
LogUtil.log(EventUtils.getMessage(EVENT_TYPE, "failed"),
e.getMessage());
	}
	}
// other methods
}
public static class EventTwoHandler implementsHandler {
	private static final String EVENT_TYPE = "EventTwo";
	@Override
	public voidhandle() {
LogUtil.log(EventUtils.getMessage(EVENT_TYPE, "start"));
	try {
 
handleEventTwo();
LogUtil.log(EventUtils.getMessage(EVENT_TYPE, "success"));
	} catch(HandleException e) {
LogUtil.log(EventUtils.getMessage(EVENT_TYPE, "failed"),
e.getMessage());
	}
	}
// other methods
}

A.
狎昵关系（Inappropriate Intimacy）/内幕交易（Insider Trading）
B.
重复代码（Duplicated Code）
C.
依恋情结（Feature Envy）
D.
异曲同工的类（Alternative Classes with Different Interfaces）

13、（单选）以下哪项不是产品在进行FMEA分析时需要考虑的因素 （B）
A.
是否涵盖了所有的功能子模块的主要故障模式
B.
是否从设计师的角度来进行定义
C.
是否考虑了最坏潜在后果
D.
是否考虑了自动恢复等对严酷度等级的影响

14、（单选）小江负责平台模块A的开发，为某产品上层模块B提供服务，但小江发现每次B模块新增需求的时候，A模块总要一起修改，认为不合理，平台不应该与产品业务逻辑耦合。于是小江决定重构，将A模块中经常随B模块变化的地方提炼出来，设计成回调，将经常变化的地方由产品注册的回调函数来处理。 请结合上述问题背景，小江的重构方法主要尊循的设计原则是（D）
A.
合成复用原则（Composite Reuse Principle）
B.
接口隔离原则（Interface Segregation Principle）
C.
迪米特法则（Law of Demeter）
D.
开闭原则（Open Closed Principle）

15、（单选）下面代码用于基于设备类型判断风扇转速是否有效，考虑到设备类型以及风扇速度类都有可能经常扩展，下面重构方法利于扩展的是（D）

cpp
bool isValidSpeed(int fanSpeed){
	if (fanSpeed != SPEED_1 && fanSpeed != SPEED_2 &&
fanSpeed != SPEED_3) {
	return false;
	}
int realDevType = GetRealDevType();
if ((realDevType== TYPE_1 || realDevType == TYPE_2) && fanSpeed == SPEED_STOP) {
	return false;
	}
return true;
}
return true;
}

A.
realDevType的值通过函数参数传进来
B.
函数本身功能简单，不需再优化
C.
直接将两个if判断部分代码直接拆分成独立函数
D.
针对fanSpeed和realDevType以查表方式重构代码

17、（单选）下面可以防止暴力破解密码的是 （B）
A.
口令中强制要求增加特殊字符
B.
增加认证验证码校验
C.
口令长度至少10个字节
D.
定期更新帐号口令



19、（单选）适配器模式的使用场景 （D）
A.
在一对多的情况下，当一个对象的状态改变，所有依赖于它的对象都需要得到通知
B.
子系统很复杂，提供更高层封装，减少用户和子系统之间的耦合
C.
在提供一个产品类库时，只暴露其接口而不暴露内部实现
D.
当需要创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的
类）协同工作



21、（单选）在进行组件化建模设计过程中，需要评估组件依赖，如下关于组件依赖说法错误的是（D）
A.
依赖倒置的典型技术包括插件机制，依赖注入等
B.
组件被依赖会导致组件修改影响其他组件，因此被依赖越少，越容易修改；被依赖越多，越难于修改
C.
组件间的依赖，应基于更加抽象和稳定的接口，而不依赖于具体的实现
D.
尽可能让稳定性高的组件依赖于稳定性低的组件



23、（单选）如下代码存在哪种坏味道（请忽略不同编程语言的规范差异）（ D）
class User {
	private ContentInfo;
	public void GetUserAddress Address& address){
	address.country = ContentInfo.getCountry();
	address.city = ContentInfo.getCity();
	address.street = ContentInfo.getStreet();
	address.community = ContentInfo.getCommunity();
	address.building = ContentInfo.getBuilding();
	address.floor = ContentInfo.getFloor();
	}
}
A.
中间人（Middle Man）
B.
狎昵关系（Inappropriate Intimacy）/内幕交易（Insider Trading）
C.
数据泥团（Data Clumps）
D.
依恋情结（ Feature Envy）

24、（单选）以下对于是否应当重构的说法, 错误的是 （C）
A.
检视时发现当前代码架构不合理，但是临近项目DeadLine，此时不应该立刻重构
B.
当前代码架构无法支撑新增功能，应该先重构再新增功能
C.
在版本迭代开发过程中修改问题单时，应尽量保持最小修改，不应当重构
D.
新增功能时发现老代码分支太多、嵌套太深，导致阅读困难、无法理解代码意图时应该先重构

25、（单选）某网站会让用户设置一个个性签名，用户登录成功后网站会将用户的个性签名显示
出来，此方案消减的是哪种威胁（A）

A.
处理过程仿冒

B.
外部交互方仿冒
C.
处理过程的抵赖
D.
外部交互方的抵赖
E.
处理过程的篡改

26、（单选）项目组近期交给小华一个重构任务，函数类似下面（B）

int register(username, type, password, gender, age){
	switch(type){
		case 1:
			// 用户
		case 2:
			// 主编
		case 3:
			// 管理员
	}
}

A.
通过引入参数对象（Introduce Parameter Object），把register方法过多的的方法参数封装成一个或几个对象，消减过长函数（Long Method）的坏味道
B.
通过以多态取代条件式（Replace Conditional with Polymorphism）的手法将不同角色的注册逻辑独立出来，消除过长函数（Long Method）的坏味道
C.
引入解释性变量（Introduce Explaining Variable），消除过长函数（Long Method）的坏味道
D.
将函数使用的注册基本信息相关的参数聚合成一个对象User，解决用户注册信息逐渐增多带来的霰弹式修改（Shotgun Surgery）问题

27、（单选）某设备软件有一消息处理函数，其代码段如下所示，考虑其循环体内判断逻辑复杂，拟对其进行重构,针对本次重构，请忽略不同语言的规范和语法差异，如下分析正确的是（B）
void ProcOverheadMsg(const uint32 maxCount, const uint32 msgQueueId)
{
	uint32 index = VOS_NULL_LONG;
	uint32 msgNum = GetMsgNum(cellQueueId);
	bool flag = false;
	bool timeFlag = false;
	for (uint32 count = 1; count < maxCount; count++)
	{
		timeFlag = false;
		flag = ((0 != (count % 6)) || ((VOS_NULL_LONG == msgNum) || (0 == msgNum)));
		if (true == flag)
		{
			index = GetFirstNode(SPEED_CTRL_LIST_HEAD, 0);
			if (VOS_NULL_LONG != index)
			{
				timeFlag = true;
				ProTimerList(index);
				continue;
			}
		}
		flag = ((0 == (count % 6)) || (false == timeFlag));
		if (true == flag)
		{
			flag = ((VOS_NULL_LONG != msgNum) && (0 != msgNum));
			if (true == flag)
			{
				msgNum = ProcOverheadInfo(msgNum);
			}
		}
	}
	return;

	}
// 经分析优化，重构后的函数为：
bool IsMsgNumValid(uint32 msgNum)
{
 return ((msgNum != VOS_NULL_LONG) && (msgNum != 0));
}
void ProcOverheadMsg(const uint32 maxCount, const uint32 msgQueueId)
{
	uint32 index = VOS_NULL_LONG;
	uint32 msgNum = GetMsgNum(cellQueueId);
	for (uint32 count = 1; count < maxCount; count++)
	{
		if (((count % 6) != 0) || !(IsMsgNumValid(msgNum)))
		{
		index = GetFirstNode(SPEED_CTRL_LIST_HEAD, 0);
		if (index != VOS_NULL_LONG)
			{
			ProTimerList(index);
			continue;
			}
		}
	if (IsMsgNumValid(msgNum))
	{
	msgNum = ProcOverheadInfo(msgNum);
	}
	}
	return;
}

A.
函数循环体内“if (IsMsgNumValid (msgNum))”是多余的，可以直接删除，不影响功能
B.
重构后的函数功能和原来函数功能是一致的
C.
重构后的函数功能将判断条件合并太多，导致功能与原函数不一致
D.
原函数通过状态标记flag更能清晰反应处理逻辑，且每个标记都是必须的

28、（单选）产品对外发布的软件（包含软件包/补丁包）必须提供完整性校验机制，在安装、
升级过程中对软件进行完整性验证，下列说法正确的是（D）
A.
在安装、升级过程中对产品的软件进行完整性验证，对于补丁包不需要提供完整性验证
B.
产品对外发布的软件（包含软件包/补丁包），需具备完整性保护机制，建议采用数字签名，不允许使用哈希值
验证
C.
对于面向企业客户的产品，在产品CPI(Customer Product Information)资料中应说明需要安装的软件，但是
不需要说明如何验证软件的合法性
D.
对于面向运营商的产品，在产品CPI(Customer Product Information)资料中应说明需要安装的软件，以及如何验证软件的合法性

29、（单选）威胁分析时需要考虑隐私的场景是（C）
A.
涉及到认证鉴权等安全机制的场景
B.
涉及到金钱交易的场景
C.
涉及到个人数据传输的场景
D.
涉及到业务敏感数据传输的场景

30、（多选）产品出于定位问题目的从客户网络导出的包含个人数据的数据时应对个人数据进行过滤或匿名化处理，以下哪些属于个人数据？ （ABD）
A.
手机串号(IMEI)
B.
移动终端IP地址

C.
骨干网路由器接口MAC地址
D.
SIM卡串号(IMSI)

31、（多选）对需求排序需考虑的因素，下列描述正确的有（ABC）
A.
紧急程度和成本
B.
是否符合产品现阶段的战略目标
C.
用KANO模型定义需求属性
D.
需求的影响程度不是考虑因素

32、（多选）适合FMEA的场景包括 （ABCD）
A.
历史上发生问题较多模块
B.
多个进程间多个模块交互软硬件交互较多模块
C.
新业务、新开发或变更较多模块
D.
状态机复杂或处理过程复杂模块

33、（多选）某产品现有代码中有一个超大函数，有850行代码18个参数和31个局部变量，以下手法中可以直接减少该函数代码量并减少参数和局部变量个数的有哪些 （AC）
A.
通过提炼函数（Extract Method）的手法，提取一批功能内聚、名称通俗易懂的函数
B.
通过内联函数（Inline Function/Inline Method）的手法将封装不良的下层函数直接展开到当前函数中
C.
引入参数对象（Introduce Parameter Object），把参数封装成一个或几个类，将参数封装成对象后提高了代
码的可读性，并且该参数对象也可以供多个方法调用
D.
为了提高可读性，决定引入解释性变量（Introduce Explaining Variable），把其中某些复杂表达式（即使只出现一次）结果放到命名良好的局部变量中

34、（多选）对如下代码进行重构说法正确的是（ACD）
class card
	......
	//LineCard
	void registerLineCard(long boardId, long model,long chipNpNumber,long chipTmNumber, long chippNumber, long power, boolean isBridge)
	{
		//汪册基本信息
		this.registerModel(boardId, model);
		this.registerchiptNpNumber(boardId, chiptNpNumber)
		this.registerchiptTmNumber(boardId, chipTmlumber)
		this.registerIsBridge(boardId, isBridge);

		//计算功耗
		long sumPower = power:
		if (chippNumber > 2){
		sumPower = power * 1.2
		}
		if (power <= 200) {
			this.registerPower(boardId, power * 0.98);
		} else {
			this.registerPower(boardId, power * 1.02);
		}
	}

	// Control Card
	void registerControlCard(long boardId, long model,long chipNpNumber,long chipTmNumber, long power, boolean isBridge)
	{
		//注册基本信息
		this.registerModel(boardId, model);
		this.registerchiptNpNumber(boardId, chiptNpNumber)
		this.registerchiptTmNumber(boardId, chipTmlumber)
		this.registerIsBridge(boardId, isBridge);

		//计算功耗
		long sumPower = power
		if (chippNumber > 1)
		{
			sumPower = power * 1.2
		}
		if (power <= 150) {
			this.registerPower (boardId, power * 0.98);
		} else {
			this.registerPower(boardId, power * 1.02);
		}
	}
// ......
}
A.
将代码中0.98、1.02等这些数字提取成变量或常量，通过变量或常量名表达其业务意义，有助于提升代码的可读性
B.
将Card类直接拆分为LineCard类和ControlCard类，并将注册接口直接搬移到各自对应的类，即可使类方法变少，代码变少
C.
将函数使用的注册基本信息相关的参数聚合成一个对象，可以减少registerLineCard()和registerControlCard()函数参数，消除数据泥团
D.
将registerLineCard()和 registerControlCard()函数中基本信息注册、功耗计算提炼成两个公共函数registerBaseInfo()、calcPower()，可以去除功能重复代码

35、（多选）设计模式一般被分为三大类，其中行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配，下列模式中属于行为模式的是 （AB）
A.
观察者（Observer)
B.
职责链（Chain of Responsibility）
C.
适配器（Adapter）
D.
抽象工厂（Abstract Factory)

36、（多选）下列哪些属于UML静态图 （ABD）
A.
对象图（Object Diagram）
B.
用例图（Use-Case Diagram）

C.
状态图（State Diagram）
D.
类图（Class Diagram）

37、（多选）下面关于模板方法正确的是 （BC）
A.
为了减少对象创建数量，降低内存占用和提高性能
B.
操作的整体步骤固定，其中小部分容易变动的场景
C.
各子类中公共的行为需要被提取出来并集中到一个公共父类中以避免代码重复
D.
一个请求操作需要多个对象处理时

38、（多选）下面关于安全设计模式说法，正确的是 （ABC）
A.
SSO单点登录，是使用身份联合模式的一种具体应用。
B.
对于蠕虫、木马、病毒、恶意程序、SQL注入等攻击入侵检测，采用“基于特征的入侵检测模式”来设计更方便。
C.
基于策略的访问控制模式中，策略决策点的性能可能会成为系统瓶颈。
D.
安全设计模式能够有利于分析攻击者的物理攻击路径，构筑纵深防御。

39、（多选）关于需求质量分析描述，不满足可验证性的是（ABD）
A.
描述系统性能指标需求为“系统正常的响应时间应少于2秒”
B.
新单板支持快速启动
C.
用户密码输入错误超过5次时，提示用户“对不起，您密码重试次数已达到限制”
D.
新老版本保持兼容

40、（多选）对于创建型设计模式描述正确的是（ABCD）
A.
单例（Singleton）能够保证一个类在实例化后，在全局中只有一个实例
B.
工厂方法（Factory Method）是一种创建型模式，工厂方法通常在模板方法（Template Methods）中被调用
C.
抽象工厂（Abstract Factory）能够无需指定具体的类，通过多态的方式创建一系列相关的对象
D.
生成器（Builder）能够灵活组装对象，可以使用相同的创建代码生成不同类型和形式的对象

41、（多选）对需求分析的理解，下面描述正确的是（ACD）
A.
需求分析过程中，需要将需求转化成形式化的功能规约，如需求规格说明书
B.
采用敏捷流程后，需求分析完成后，可以不用输出形式化的功能规约
C.
需求分析时，对业务目标、业务场景和使用约束等都需要考虑
D.
需求分析中，对不明确的功能需求，要进行细致调查后进行具体化

42、（多选）关于威胁的理解， 下面正确的是（ACD）
A.
威胁不会因为系统进行了安全防护就消失
B.
系统面临威胁的多少取决于系统有多少个安全漏洞
C.
威胁会随系统环境、场景的改变而改变
D.
威胁是一种潜在的破坏系统安全的因素

43、（多选）需求分析中UML用例图中的用例 (Use-case) 之间存在哪些关系（CD）
A.
组合（Composition）
B.
聚合（Aggregation）

C.
包含（Include）
D.
扩展（Extend）
